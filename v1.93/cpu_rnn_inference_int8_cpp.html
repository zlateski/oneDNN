<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>oneDNN: RNN int8 inference example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">oneAPI Deep Neural Network Library (oneDNN)
   &#160;<span id="projectnumber">1.93.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RNN int8 inference example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This C++ API example demonstrates how to build GNMT model inference.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html">cpu_rnn_inference_int8.cpp</a></p>
<p></p>
</blockquote>
<p>For the encoder we use:</p>
<ul>
<li>one primitive for the bidirectional layer of the encoder</li>
<li>one primitive for all remaining unidirectional layers in the encoder For the decoder we use:</li>
<li>one primitive for the first iteration</li>
<li>one primitive for all subsequent iterations in the decoder. Note that in this example, this primitive computes the states in place.</li>
<li>the attention mechanism is implemented separately as there is no support for the context vectors in oneDNN yet</li>
</ul>
<p>Initialize a CPU engine and stream. The last parameter in the call represents the index of the engine. </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> cpu_engine = engine(engine::kind::cpu, 0);</div>
<div class="line">    stream s(cpu_engine);</div>
</div><!-- fragment --><p>Declare encoder net and decoder net </p>
<div class="fragment"><div class="line">    std::vector&lt;primitive&gt; encoder_net, decoder_net;</div>
<div class="line">    std::vector&lt;std::unordered_map&lt;int, memory&gt;&gt; encoder_net_args,</div>
<div class="line">            decoder_net_args;</div>
<div class="line"></div>
<div class="line">    std::vector&lt;float&gt; net_src(batch * src_seq_length_max * feature_size, 0.1f);</div>
<div class="line">    std::vector&lt;float&gt; net_dst(batch * tgt_seq_length_max * feature_size, 0.1f);</div>
</div><!-- fragment --><p>Quantization factors for f32 data </p>
<div class="fragment"><div class="line">    std::vector&lt;float&gt; weights_scales(lstm_n_gates * feature_size);</div>
<div class="line">    <span class="comment">// assign halves of vector with arbitrary values</span></div>
<div class="line">    <span class="keyword">const</span> dim_t scales_half = lstm_n_gates * feature_size / 2;</div>
<div class="line">    std::fill(</div>
<div class="line">            weights_scales.begin(), weights_scales.begin() + scales_half, 30.f);</div>
<div class="line">    std::fill(</div>
<div class="line">            weights_scales.begin() + scales_half, weights_scales.end(), 65.5f);</div>
</div><!-- fragment --><p><b>Encoder</b></p>
<p>Initialize Encoder Memory </p>
<div class="fragment"><div class="line">    memory::dims enc_bidir_src_layer_tz</div>
<div class="line">            = {src_seq_length_max, batch, feature_size};</div>
<div class="line">    memory::dims enc_bidir_weights_layer_tz</div>
<div class="line">            = {enc_bidir_n_layers, 2, feature_size, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims enc_bidir_weights_iter_tz</div>
<div class="line">            = {enc_bidir_n_layers, 2, feature_size, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims enc_bidir_bias_tz</div>
<div class="line">            = {enc_bidir_n_layers, 2, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims enc_bidir_dst_layer_tz</div>
<div class="line">            = {src_seq_length_max, batch, 2 * feature_size};</div>
<div class="line"></div>
</div><!-- fragment --><p>Encoder: 1 bidirectional layer and 7 unidirectional layers</p>
<p>Create the memory for user data </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> user_enc_bidir_src_layer_md = memory::desc({enc_bidir_src_layer_tz},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::tnc);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_layer_md</div>
<div class="line">            = memory::desc({enc_bidir_weights_layer_tz}, memory::data_type::f32,</div>
<div class="line">                    memory::format_tag::ldigo);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_iter_md = memory::desc({enc_bidir_weights_iter_tz},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldigo);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_bias_md = memory::desc({enc_bidir_bias_tz},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldgo);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_src_layer_memory</div>
<div class="line">            = memory(user_enc_bidir_src_layer_md, cpu_engine, net_src.data());</div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_layer_memory = memory(user_enc_bidir_wei_layer_md,</div>
<div class="line">            cpu_engine, user_enc_bidir_wei_layer.data());</div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_iter_memory = memory(user_enc_bidir_wei_iter_md,</div>
<div class="line">            cpu_engine, user_enc_bidir_wei_iter.data());</div>
<div class="line">    <span class="keyword">auto</span> user_enc_bidir_bias_memory = memory(</div>
<div class="line">            user_enc_bidir_bias_md, cpu_engine, user_enc_bidir_bias.data());</div>
</div><!-- fragment --><p>Create memory descriptors for RNN data w/o specified layout </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_md = memory::desc({enc_bidir_src_layer_tz},</div>
<div class="line">            memory::data_type::u8, memory::format_tag::any);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> enc_bidir_wei_layer_md = memory::desc({enc_bidir_weights_layer_tz},</div>
<div class="line">            memory::data_type::s8, memory::format_tag::any);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> enc_bidir_wei_iter_md = memory::desc({enc_bidir_weights_iter_tz},</div>
<div class="line">            memory::data_type::s8, memory::format_tag::any);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> enc_bidir_dst_layer_md = memory::desc({enc_bidir_dst_layer_tz},</div>
<div class="line">            memory::data_type::u8, memory::format_tag::any);</div>
</div><!-- fragment --><p>Create bidirectional RNN</p>
<div class="fragment"><div class="line">    lstm_forward::desc bi_layer_desc(prop_kind::forward_inference,</div>
<div class="line">            rnn_direction::bidirectional_concat, enc_bidir_src_layer_md,</div>
<div class="line">            memory::desc(), memory::desc(), enc_bidir_wei_layer_md,</div>
<div class="line">            enc_bidir_wei_iter_md, user_enc_bidir_bias_md,</div>
<div class="line">            enc_bidir_dst_layer_md, memory::desc(), memory::desc());</div>
</div><!-- fragment --><p>Define RNN attributes that store quantization parameters </p>
<div class="fragment"><div class="line">    primitive_attr attr;</div>
<div class="line">    attr.set_rnn_data_qparams(data_scale, data_shift);</div>
<div class="line">    attr.set_rnn_weights_qparams(weights_scale_mask, weights_scales);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> enc_bidir_prim_desc</div>
<div class="line">            = lstm_forward::primitive_desc(bi_layer_desc, attr, cpu_engine);</div>
</div><!-- fragment --><p>Create memory for input data and use reorders to quantize values to int8 NOTE: same attributes are used when creating RNN primitive and reorders </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_memory</div>
<div class="line">            = memory(enc_bidir_prim_desc.src_layer_desc(), cpu_engine);</div>
<div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_reorder_pd = reorder::primitive_desc(</div>
<div class="line">            user_enc_bidir_src_layer_memory, enc_bidir_src_layer_memory, attr);</div>
<div class="line">    encoder_net.push_back(reorder(enc_bidir_src_layer_reorder_pd));</div>
<div class="line">    encoder_net_args.push_back(</div>
<div class="line">            {{<a class="code" href="group__dnnl__api__primitives__common.html#ga953b34f004a8222b04e21851487c611a">DNNL_ARG_FROM</a>, user_enc_bidir_src_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gaf700c3396987b450413c8df5d78bafd9">DNNL_ARG_TO</a>, enc_bidir_src_layer_memory}});</div>
</div><!-- fragment --><p>Encoder : add the bidirectional rnn primitive with related arguments into encoder_net </p>
<div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_bidir_prim_desc));</div>
<div class="line">    encoder_net_args.push_back(</div>
<div class="line">            {{<a class="code" href="group__dnnl__api__primitives__common.html#gab91ce4d04cf4e98e3a407daa0676764f">DNNL_ARG_SRC_LAYER</a>, enc_bidir_src_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga1ac9e1f1327be3902b488b64bae1b4c5">DNNL_ARG_WEIGHTS_LAYER</a>, enc_bidir_wei_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga5a9c39486c01ad263e29677a32735af8">DNNL_ARG_WEIGHTS_ITER</a>, enc_bidir_wei_iter_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gad0cbc09942aba93fbe3c0c2e09166f0d">DNNL_ARG_BIAS</a>, user_enc_bidir_bias_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gacfc123a6a4ff3b4af4cd27ed66fb8528">DNNL_ARG_DST_LAYER</a>, enc_bidir_dst_layer_memory}});</div>
</div><!-- fragment --><p>Encoder: unidirectional layers</p>
<p>First unidirectinal layer scales 2 * feature_size output of bidirectional layer to feature_size output </p>
<div class="fragment"><div class="line">    std::vector&lt;float&gt; user_enc_uni_first_wei_layer(</div>
<div class="line">            1 * 1 * 2 * feature_size * lstm_n_gates * feature_size, 0.3f);</div>
<div class="line">    std::vector&lt;float&gt; user_enc_uni_first_wei_iter(</div>
<div class="line">            1 * 1 * feature_size * lstm_n_gates * feature_size, 0.2f);</div>
<div class="line">    std::vector&lt;float&gt; user_enc_uni_first_bias(</div>
<div class="line">            1 * 1 * lstm_n_gates * feature_size, 1.0f);</div>
</div><!-- fragment --><p>Encoder : Create unidirection RNN for first cell </p>
<div class="fragment"><div class="line"></div>
<div class="line">    lstm_forward::desc enc_uni_first_layer_desc(prop_kind::forward_inference,</div>
<div class="line">            rnn_direction::unidirectional_left2right, enc_bidir_dst_layer_md,</div>
<div class="line">            memory::desc(), memory::desc(), enc_uni_first_wei_layer_md,</div>
<div class="line">            enc_uni_first_wei_iter_md, user_enc_uni_first_bias_md,</div>
<div class="line">            enc_uni_first_dst_layer_md, memory::desc(), memory::desc());</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> enc_uni_first_prim_desc = lstm_forward::primitive_desc(</div>
<div class="line">            enc_uni_first_layer_desc, attr, cpu_engine);</div>
</div><!-- fragment --><p>Encoder : add the first unidirectional rnn primitive with related arguments into encoder_net </p>
<div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_uni_first_prim_desc));</div>
<div class="line">    encoder_net_args.push_back(</div>
<div class="line">            {{<a class="code" href="group__dnnl__api__primitives__common.html#gab91ce4d04cf4e98e3a407daa0676764f">DNNL_ARG_SRC_LAYER</a>, enc_bidir_dst_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga1ac9e1f1327be3902b488b64bae1b4c5">DNNL_ARG_WEIGHTS_LAYER</a>, enc_uni_first_wei_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga5a9c39486c01ad263e29677a32735af8">DNNL_ARG_WEIGHTS_ITER</a>, enc_uni_first_wei_iter_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gad0cbc09942aba93fbe3c0c2e09166f0d">DNNL_ARG_BIAS</a>, user_enc_uni_first_bias_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gacfc123a6a4ff3b4af4cd27ed66fb8528">DNNL_ARG_DST_LAYER</a>, enc_uni_first_dst_layer_memory}});</div>
</div><!-- fragment --><p>Encoder : Remaining unidirectional layers </p>
<div class="fragment"><div class="line">    std::vector&lt;float&gt; user_enc_uni_wei_layer((enc_unidir_n_layers - 1) * 1</div>
<div class="line">                    * feature_size * lstm_n_gates * feature_size,</div>
<div class="line">            0.3f);</div>
<div class="line">    std::vector&lt;float&gt; user_enc_uni_wei_iter((enc_unidir_n_layers - 1) * 1</div>
<div class="line">                    * feature_size * lstm_n_gates * feature_size,</div>
<div class="line">            0.2f);</div>
<div class="line">    std::vector&lt;float&gt; user_enc_uni_bias(</div>
<div class="line">            (enc_unidir_n_layers - 1) * 1 * lstm_n_gates * feature_size, 1.0f);</div>
</div><!-- fragment --><p>Encoder : Create unidirection RNN cell </p>
<div class="fragment"><div class="line"></div>
<div class="line">    lstm_forward::desc enc_uni_layer_desc(prop_kind::forward_inference,</div>
<div class="line">            rnn_direction::unidirectional_left2right,</div>
<div class="line">            enc_uni_first_dst_layer_md, memory::desc(), memory::desc(),</div>
<div class="line">            enc_uni_wei_layer_md, enc_uni_wei_iter_md, user_enc_uni_bias_md,</div>
<div class="line">            enc_dst_layer_md, memory::desc(), memory::desc());</div>
<div class="line">    <span class="keyword">auto</span> enc_uni_prim_desc = lstm_forward::primitive_desc(</div>
<div class="line">            enc_uni_layer_desc, attr, cpu_engine);</div>
</div><!-- fragment --><p>Encoder : add the unidirectional rnn primitive with related arguments into encoder_net </p>
<div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_uni_prim_desc));</div>
<div class="line">    encoder_net_args.push_back(</div>
<div class="line">            {{<a class="code" href="group__dnnl__api__primitives__common.html#gab91ce4d04cf4e98e3a407daa0676764f">DNNL_ARG_SRC_LAYER</a>, enc_uni_first_dst_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga1ac9e1f1327be3902b488b64bae1b4c5">DNNL_ARG_WEIGHTS_LAYER</a>, enc_uni_wei_layer_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga5a9c39486c01ad263e29677a32735af8">DNNL_ARG_WEIGHTS_ITER</a>, enc_uni_wei_iter_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gad0cbc09942aba93fbe3c0c2e09166f0d">DNNL_ARG_BIAS</a>, user_enc_uni_bias_memory},</div>
<div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gacfc123a6a4ff3b4af4cd27ed66fb8528">DNNL_ARG_DST_LAYER</a>, enc_dst_layer_memory}});</div>
</div><!-- fragment --><p><b>Decoder with attention mechanism</b></p>
<p>Decoder : declare memory dimensions </p>
<div class="fragment"><div class="line">    std::vector&lt;float&gt; user_dec_wei_layer(</div>
<div class="line">            dec_n_layers * 1 * feature_size * lstm_n_gates * feature_size,</div>
<div class="line">            0.2f);</div>
<div class="line">    std::vector&lt;float&gt; user_dec_wei_iter(dec_n_layers * 1</div>
<div class="line">                    * (feature_size + feature_size) * lstm_n_gates</div>
<div class="line">                    * feature_size,</div>
<div class="line">            0.3f);</div>
<div class="line">    std::vector&lt;float&gt; user_dec_bias(</div>
<div class="line">            dec_n_layers * 1 * lstm_n_gates * feature_size, 1.0f);</div>
<div class="line">    std::vector&lt;int8_t&gt; user_weights_attention_src_layer(</div>
<div class="line">            feature_size * feature_size, 1);</div>
<div class="line">    <span class="keywordtype">float</span> weights_attention_scale = 127.;</div>
<div class="line">    std::vector&lt;float&gt; user_weights_annotation(</div>
<div class="line">            feature_size * feature_size, 1.0f);</div>
<div class="line">    std::vector&lt;float&gt; user_weights_alignments(feature_size, 1.0f);</div>
<div class="line">    <span class="comment">// Buffer to store decoder output for all iterations</span></div>
<div class="line">    std::vector&lt;uint8_t&gt; dec_dst(tgt_seq_length_max * batch * feature_size, 0);</div>
<div class="line"></div>
<div class="line">    memory::dims user_dec_wei_layer_dims</div>
<div class="line">            = {dec_n_layers, 1, feature_size, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims user_dec_wei_iter_dims = {dec_n_layers, 1,</div>
<div class="line">            feature_size + feature_size, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims user_dec_bias_dims</div>
<div class="line">            = {dec_n_layers, 1, lstm_n_gates, feature_size};</div>
<div class="line">    memory::dims dec_src_layer_dims = {1, batch, feature_size};</div>
<div class="line">    memory::dims dec_dst_layer_dims = {1, batch, feature_size};</div>
<div class="line">    memory::dims dec_dst_iter_c_dims = {dec_n_layers, 1, batch, feature_size};</div>
</div><!-- fragment --><div class="fragment"><div class="line">    memory::dims dec_dst_iter_dims</div>
<div class="line">            = {dec_n_layers, 1, batch, feature_size + feature_size};</div>
<div class="line">    memory::dims dec_dst_iter_noctx_dims</div>
<div class="line">            = {dec_n_layers, 1, batch, feature_size};</div>
</div><!-- fragment --><p>Decoder : create memory description Create memory descriptors for RNN data w/o specified layout </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> user_dec_wei_layer_md = memory::desc({user_dec_wei_layer_dims},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldigo);</div>
<div class="line">    <span class="keyword">auto</span> user_dec_wei_iter_md = memory::desc({user_dec_wei_iter_dims},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldigo);</div>
<div class="line">    <span class="keyword">auto</span> user_dec_bias_md = memory::desc({user_dec_bias_dims},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldgo);</div>
<div class="line">    <span class="keyword">auto</span> dec_src_layer_md = memory::desc({dec_src_layer_dims},</div>
<div class="line">            memory::data_type::u8, memory::format_tag::tnc);</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_layer_md = memory::desc({dec_dst_layer_dims},</div>
<div class="line">            memory::data_type::u8, memory::format_tag::tnc);</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_iter_md = memory::desc({dec_dst_iter_dims},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldnc);</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_iter_c_md = memory::desc({dec_dst_iter_c_dims},</div>
<div class="line">            memory::data_type::f32, memory::format_tag::ldnc);</div>
</div><!-- fragment --><p>Decoder : Create memory </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> user_dec_wei_layer_memory = memory(</div>
<div class="line">            user_dec_wei_layer_md, cpu_engine, user_dec_wei_layer.data());</div>
<div class="line">    <span class="keyword">auto</span> user_dec_wei_iter_memory = memory(</div>
<div class="line">            user_dec_wei_iter_md, cpu_engine, user_dec_wei_iter.data());</div>
<div class="line">    <span class="keyword">auto</span> user_dec_bias_memory</div>
<div class="line">            = memory(user_dec_bias_md, cpu_engine, user_dec_bias.data());</div>
<div class="line">    <span class="keyword">auto</span> dec_src_layer_memory = memory(dec_src_layer_md, cpu_engine);</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_layer_memory</div>
<div class="line">            = memory(dec_dst_layer_md, cpu_engine, dec_dst.data());</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_iter_c_memory = memory(dec_dst_iter_c_md, cpu_engine);</div>
</div><!-- fragment --><p>Decoder : As mentioned above, we create a view without context out of the memory with context. </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> dec_dst_iter_memory = memory(dec_dst_iter_md, cpu_engine);</div>
<div class="line">    <span class="keyword">auto</span> dec_dst_iter_noctx_md = dec_dst_iter_md.submemory_desc(</div>
<div class="line">            dec_dst_iter_noctx_dims, {0, 0, 0, 0, 0});</div>
</div><!-- fragment --><p>Decoder : Create memory for input data and use reorders to quantize values to int8 </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> dec_wei_layer_memory</div>
<div class="line">            = memory(dec_ctx_prim_desc.weights_layer_desc(), cpu_engine);</div>
<div class="line">    <span class="keyword">auto</span> dec_wei_layer_reorder_pd = reorder::primitive_desc(</div>
<div class="line">            user_dec_wei_layer_memory, dec_wei_layer_memory, attr);</div>
<div class="line">    reorder(dec_wei_layer_reorder_pd)</div>
<div class="line">            .execute(s, user_dec_wei_layer_memory, dec_wei_layer_memory);</div>
</div><!-- fragment --><p><b>Execution</b></p>
<p>run encoder (1 stream) </p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; encoder_net.size(); ++p)</div>
<div class="line">            encoder_net.at(p).execute(s, encoder_net_args.at(p));</div>
</div><!-- fragment --><p>we compute the weighted annotations once before the decoder </p>
<div class="fragment"><div class="line">        compute_weighted_annotations(weighted_annotations.data(),</div>
<div class="line">                src_seq_length_max, batch, feature_size,</div>
<div class="line">                user_weights_annotation.data(),</div>
<div class="line">                (<span class="keywordtype">float</span> *)enc_dst_layer_memory.get_data_handle());</div>
</div><!-- fragment --><p>precompute compensation for s8u8s32 gemm in compute attention </p>
<div class="fragment"><div class="line">        compute_sum_of_rows(user_weights_attention_src_layer.data(),</div>
<div class="line">                feature_size, feature_size, weights_attention_sum_rows.data());</div>
</div><!-- fragment --><p>We initialize src_layer to the embedding of the end of sequence character, which are assumed to be 0 here </p>
<div class="fragment"><div class="line">        memset(dec_src_layer_memory.get_data_handle(), 0,</div>
<div class="line">                dec_src_layer_memory.get_desc().get_size());</div>
</div><!-- fragment --><p>From now on, src points to the output of the last iteration</p>
<p>Compute attention context vector into the first layer src_iter </p>
<div class="fragment"><div class="line">            compute_attention(src_att_iter_handle, src_seq_length_max, batch,</div>
<div class="line">                    feature_size, user_weights_attention_src_layer.data(),</div>
<div class="line">                    weights_attention_scale, weights_attention_sum_rows.data(),</div>
<div class="line">                    src_att_layer_handle, data_scale, data_shift,</div>
<div class="line">                    (uint8_t *)enc_bidir_dst_layer_memory.get_data_handle(),</div>
<div class="line">                    weighted_annotations.data(),</div>
<div class="line">                    user_weights_alignments.data());</div>
</div><!-- fragment --><p>copy the context vectors to all layers of src_iter </p>
<div class="fragment"><div class="line">            copy_context(</div>
<div class="line">                    src_att_iter_handle, dec_n_layers, batch, feature_size);</div>
</div><!-- fragment --><p>run the decoder iteration </p>
<div class="fragment"><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; decoder_net.size(); ++p)</div>
<div class="line">                decoder_net.at(p).execute(s, decoder_net_args.at(p));</div>
</div><!-- fragment --><p>Move the handle on the src/dst layer to the next iteration </p>
<div class="fragment"><div class="line">            <span class="keyword">auto</span> dst_layer_handle</div>
<div class="line">                    = (uint8_t *)dec_dst_layer_memory.get_data_handle();</div>
<div class="line">            dec_src_layer_memory.set_data_handle(dst_layer_handle);</div>
<div class="line">            dec_dst_layer_memory.set_data_handle(</div>
<div class="line">                    dst_layer_handle + batch * feature_size);</div>
</div><!-- fragment --></div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>