<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>DNNL: Understanding Memory Formats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Deep Neural Network Library (DNNL)
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Understanding Memory Formats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>Most computations are about data: analyzing data, adjusting data, reading and storing data, generating data, etc. The DNN domain is no exception. Images, weights/filters, sound, and text require efficient representation in computer memory to facilitate performing operations fast and in the most convenient way.</p>
<p>This article is devoted to <b>data format</b> &ndash; one form of data representation that describes how multidimensional arrays (nD) are stored in linear (1D) memory address space and why this is important for <a href="https://github.com/intel/mkl-dnn/">Deep Neural Network Library (DNNL)</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For the purpose of this article, data <em>format</em> and <em>layout</em> are used interchangeably.</dd></dl>
<h3>Nomenclature used</h3>
<ul>
<li>Channels are the same as feature maps</li>
<li>Upper-case letters denote the dimensions (e.g. <code>N</code>)</li>
<li>Lower-case letters denote the index (e.g. <code>n</code>, where <code>0 &lt;= n &lt; N</code>)</li>
<li><p class="startli">The notation for the activations:</p>
<p class="startli"><em>batch</em> <b>N</b>, <em>channels</em> <b>C</b>, <em>depth</em> <b>D</b>, <em>height</em> <b>H</b>, <em>width</em> <b>W</b></p>
</li>
<li><p class="startli">The notation for the weights:</p>
<p class="startli"><em>groups</em> <b>G</b>, <em>output channels</em> <b>O</b>, <em>input channels</em> <b>I</b>, <em>depth</em> <b>D</b>, <em>height</em> <b>H</b>, <em>width</em> <b>W</b></p>
</li>
</ul>
<h2>Data formats</h2>
<p>Let's first focus on data formats for activations (images).</p>
<p>Activations consist of channels (also called feature maps) and a spatial domain, 1D, 2D, or 3D. The spatial domain together with channels form an image. During the training phase, images are typically grouped together in batches. Even if there is only one image, we still assume that there is a batch with batch size equal to 1. Hence, the overall dimensionality of activations is 4D (<b>N</b>, <b>C</b>, <b>H</b>, and <b>W</b>) or 5D (<b>N</b>, <b>C</b>, <b>D</b>, <b>H</b>, and <b>W</b>).</p>
<p>For the sake of simplicity, we will use only 2D spatial in this article.</p>
<h3>Plain data formats</h3>
<p>It would be simpler to start with an example.</p>
<p>Consider 4D activations with batch equals 2, 16 channels, and 5 x 4 spatial domain. Logical representation is given in the picture below. </p>
<div class="image">
<img src="mem_fmt_img1.png" alt="mem_fmt_img1.png"/>
<div class="caption">
Activations</div></div>
<p> The value at the position (n, c, h, w) is generated with the following formula: </p>
<div class="fragment"><div class="line">value(n, c, h, w) = n * CHW + c * HW + h * W + w</div>
</div><!-- fragment --><p>In order to define how data in this 4D-tensor is laid out in memory, we need to define how to map it to a 1D tensor via an <b>offset</b> function that takes a logical index (n, c, h, w) as an input and returns an address displacement to the location of the value: </p>
<div class="fragment"><div class="line">offset : (int, int, int, int) --&gt; int</div>
</div><!-- fragment --><h4>NCHW</h4>
<p>Let's describe the order in which the tensor values are laid out in memory for one of the very popular formats, <b>NCHW</b>. The <code>[a:?]</code> marks refer to the jumps shown in the picture below, which shows the 1D representation of an NCHW tensor in memory.</p>
<ul>
<li><code>[a:0]</code> First within a line, from left to right</li>
<li><code>[a:1]</code> Then line by line from top to bottom</li>
<li><code>[a:2]</code> Then go from one plane to another (in depth)</li>
<li><code>[a:3]</code> And finally switch from one image in a batch (<b>n</b> = 0) to another (<b>n</b> = 1)</li>
</ul>
<p>Then the offset function is: </p>
<div class="fragment"><div class="line">offset_nchw(n, c, h, w) = n * CHW + c * HW + h * W + w</div>
</div><!-- fragment --><p>We use <code>nchw</code> here to denote that <code>w</code> is the inner-most dimension, meaning that two elements adjacent in memory would share the same indices of <code>n</code>, <code>c</code>, and <code>h</code>, and their index of <code>w</code> would be different by <code>1</code>. This is of course true only for non-border elements. On the contrary, <code>n</code> is the outermost dimension here, meaning that if you need to take the same pixel <code>(c, h, w)</code> but on the next image, you have to jump over the whole image size <code>C*H*W</code>.</p>
<p>This data format is called <b>NCHW</b> and is used by default in BVLC* Caffe. TensorFlow* also supports this data format.</p>
<dl class="section note"><dt>Note</dt><dd>It is just a coincidence that <code>offset_nchw()</code> is the same as <code>value()</code> in this example.</dd></dl>
<p>One can create memory with <b>NCHW</b> data layout using <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da83a751aedeb59613312339d0f8b90f54" title="4D CNN activations tensor, an alias to dnnl_abcd ">dnnl_nchw</a> of the enum type <a class="el" href="group__dnnl__api__memory.html#ga395e42b594683adb25ed2d842bb3091d" title="Memory format tag specification. ">dnnl_format_tag_t</a> defined in <a href="https://github.com/intel/mkl-dnn/blob/master/include/dnnl_types.h">dnnl_types.h</a> for the C API, and <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3faded7ac40158367123c5467281d44cbeb" title="4D CNN activations tensor; an alias for dnnl::memory::format_tag::abcd ">dnnl::memory::format_tag::nchw</a> defined in <a href="https://github.com/intel/mkl-dnn/blob/master/include/dnnl.hpp">dnnl.hpp</a> for the C++ API.</p>
<h4>NHWC</h4>
<p>Another quite popular data format is <b>NHWC</b>, which uses the following offset function: </p>
<div class="fragment"><div class="line">offset_nhwc(n, c, h, w) = n * HWC + h * WC + w * C + c</div>
</div><!-- fragment --><p>In this case, the inner-most dimension is channels (<code>[b:0]</code>), which is followed by width (<code>[b:1]</code>), height (<code>[b:2]</code>), and finally batch (<code>[b:3]</code>).</p>
<p>For a single image (<b>N</b> = 1), this format is very similar to how <a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP-file format</a> works, where the image is kept pixel by pixel and every pixel contains all required information about colors (for instance, three channels for 24bit BMP).</p>
<p>NHWC data format is the default one for <a href="https://www.tensorflow.org/performance/performance_guide#data_formats">TensorFlow</a>.</p>
<p>This layout corresponds to <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae50c534446b3c18cc018b3946b3cebd7" title="4D CNN activations tensor, an alias to dnnl_acdb ">dnnl_nhwc</a> or <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa763cbf7ba1b7b8793dcdc6e2157b5c42" title="4D CNN activations tensor; an alias for dnnl::memory::format_tag::acdb ">dnnl::memory::format_tag::nhwc</a>.</p>
<h4>CHWN</h4>
<p>The last example here for the plain data layout is <b>CHWN</b>, which is used by <a href="https://neon.nervanasys.com/index.html/design.html#data-layout">Neon</a>. This layout might be very interesting from a vectorization perspective if an appropriate batch size is used, but on the other hand users cannot always have <em>good</em> batch size (for example, in case of real-time inference batch is typically 1).</p>
<p>The dimensions order is (from inner-most to outer-most): batch (<code>[c:0]</code>), width (<code>[c:1]</code>), height (<code>[c:2]</code>), channels (<code>[c:3]</code>).</p>
<p>The offset function for <b>CHWN</b> format is defined as: </p>
<div class="fragment"><div class="line">offset_chwn(n, c, h, w) = c * HWN + h * WN + w * N + n</div>
</div><!-- fragment --><p>This layout corresponds to <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daab65a38658838cec19e718ba048cd459" title="4D CNN activations tensor, an alias to dnnl_bcda ">dnnl_chwn</a> or <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fafd2263500e815d8ce46e79e6b178a10a" title="4D CNN activations tensor; an alias for dnnl::memory::format_tag::bcda ">dnnl::memory::format_tag::chwn</a>.</p>
<div class="image">
<img src="mem_fmt_img2.png" alt="mem_fmt_img2.png"/>
<div class="caption">
Different plain layouts</div></div>
 <h4>Relevant reading</h4>
<p><a href="https://www.tensorflow.org/performance/xla/shapes">TensorFlow Doc. Shapes and Layout</a></p>
<h3>Generalization of the plain data layout</h3>
<h4>Strides</h4>
<p>In the previous examples the data was kept packed or in dense form, meaning pixels follow one another. Sometimes it might be necessary to not keep data contiguous in memory. For instance, some might need to work with a sub-tensor within a bigger tensor. Sometimes it might be beneficial to artificially make the data disjoint, as in case of GEMM with a non-trivial leading dimension to get better performance (<a href="https://software.intel.com/en-us/articles/a-simple-example-to-measure-the-performance-of-an-intel-mkl-function">see Tips 6</a>).</p>
<p>The following picture shows a simplified case for a 2D matrix of size <code>rows x columns</code> kept in row-major format where rows have some non-trivial (that is, not equal to the number of columns) stride.</p>
<div class="image">
<img src="strides.png" alt="strides.png"/>
<div class="caption">
Strides</div></div>
<p> In this case, the general offset function looks like: </p>
<div class="fragment"><div class="line">offset(n, c, h, w) = n * stride_n</div>
<div class="line">                   + c * stride_c</div>
<div class="line">                   + h * stride_h</div>
<div class="line">                   + w * stride_w</div>
</div><!-- fragment --><p>Note that the <b>NCHW</b>, <b>NHWC</b>, and <b>CHWN</b> formats are just special cases of the format with strides. For example, for <b>NCHW</b> we have: </p>
<div class="fragment"><div class="line">stride_n = CHW, stride_c = HW, stride_h = W, stride_w = 1</div>
</div><!-- fragment --><p>A user can initialize a memory descriptor with strides: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dnnl__api__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims = {N, C, H, W};</div>
<div class="line"><a class="code" href="group__dnnl__api__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> strides = {stride_n, stride_c, stride_h, stride_w};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> md;</div>
<div class="line"><a class="code" href="group__dnnl__api__memory.html#ga77c4ac2c6c59730ade594b954c145f73">dnnl_memory_desc_init_by_strides</a>(&amp;md, 4, dims, <a class="code" href="group__dnnl__api__memory.html#gga012ba1c84ff24bdd068f9d2f9b26a130a6b33889946b183311c39cc1bd0656ae9">dnnl_f32</a>, strides);</div>
</div><!-- fragment --><p>DNNL supports strides via blocking structure. The pseudo-code for the function above is: </p>
<div class="fragment"><div class="line">memory_desc_t md; <span class="comment">// memory descriptor object</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// logical description, layout independent</span></div>
<div class="line">md.<a class="code" href="structdnnl__memory__desc__t.html#a72ed50c98f23f513550255ca8917b473">ndims</a> = 4;           <span class="comment">// # dimensions</span></div>
<div class="line">md.<a class="code" href="structdnnl__memory__desc__t.html#a47052ab197c58af737ac2865796402ce">dims</a> = {N, C, H, W}; <span class="comment">// dimensions themselves</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// physical description</span></div>
<div class="line">md.<a class="code" href="structdnnl__memory__desc__t.html#ae6f8322c5cff0068a97e7fba2f123e2c">format_kind</a> = <a class="code" href="group__dnnl__api__memory.html#ggaa75cad747fa467d9dc527d943ba3367da30498f5adbc7d8017979a2201725ff16">dnnl_blocked</a>; <span class="comment">// generic blocked format</span></div>
<div class="line">md.format_desc.<a class="code" href="structdnnl__memory__desc__t.html#a376a38353672131bfc67fe92bceb6c9e">blocking</a>.<a class="code" href="structdnnl__blocking__desc__t.html#a48c1a3cb43f5b935fe3627e6312543b3">strides</a> = {</div>
<div class="line">    stride_n, stride_c, stride_h, stride_w</div>
<div class="line">};</div>
</div><!-- fragment --><p> In particular, whenever a user creates memory with the <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da83a751aedeb59613312339d0f8b90f54" title="4D CNN activations tensor, an alias to dnnl_abcd ">dnnl_nchw</a> format, DNNL computes the strides and fills the structure on behalf of the user.</p>
<h2>Blocked layout</h2>
<p>Plain layouts give great flexibility and are very convenient for use. That's why most of the frameworks and applications use either the <b>NCHW</b> or <b>NHWC</b> layout. However, depending on the operation that is performed on data, it might turn out that those layouts are sub-optimal from the performance perspective.</p>
<p>In order to achieve better vectorization and cache re-usage DNNL introduces blocked layout that splits one or several dimensions into the blocks of fixed size. The most popular DNNL data format is <b>nChw16c</b> on AVX512+ systems and <b>nChw8c</b> on SSE4.1+ systems. As one might guess from the name the only dimension that is blocked is channels and the block size is either 16 in the former case or 8 in the later case.</p>
<p>Precisely, the offset function for <b>nChw8c</b> is: </p>
<div class="fragment"><div class="line">offset_nChw8c(n, c, h, w) = n * CHW</div>
<div class="line">                          + (c / 8) * HW*8</div>
<div class="line">                          + h * W*8</div>
<div class="line">                          + w * 8</div>
<div class="line">                          + (c % 8)</div>
</div><!-- fragment --><p>Note that blocks of 8 channels are kept contiguously in memory. Pixel by pixel the spatial domain is covered. Then next slice covers the subsequent 8 channels (that is, moving from <code>c=0..7</code> to <code>c=8..15</code>). Once all channel blocks are covered, the next image in the batch appears.</p>
<div class="image">
<img src="mem_fmt_blk.png" alt="mem_fmt_blk.png"/>
<div class="caption">
nChw8c format</div></div>
 <dl class="section note"><dt>Note</dt><dd>We use lower- and uppercase letters in the formats to distinguish between the blocks (e.g. 8c) and the remaining co-dimension (<b>C</b> = channels / 8).</dd></dl>
<p>The reason behind the format choice can be found in <a href="https://arxiv.org/pdf/1602.06709v1.pdf">this paper</a>.</p>
<p>DNNL describes this type of memory via blocking structure as well. The pseudo-code is: </p>
<div class="fragment"><div class="line">memory_desc_t md;</div>
<div class="line"><span class="comment">// logical description, layout independent</span></div>
<div class="line">md.<a class="code" href="structdnnl__memory__desc__t.html#a72ed50c98f23f513550255ca8917b473">ndims</a> = 4;           <span class="comment">// # dimensions</span></div>
<div class="line">md.dims = {N, C, H, W}; <span class="comment">// dimensions themselves</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// physical description</span></div>
<div class="line">md.memory_format = <a class="code" href="group__dnnl__api__memory.html#ggaa75cad747fa467d9dc527d943ba3367da30498f5adbc7d8017979a2201725ff16">dnnl_blocked</a>; <span class="comment">// blocked layout</span></div>
<div class="line"></div>
<div class="line">ptrdiff_t stride_n = C*H*W;</div>
<div class="line">ptrdiff_t stride_C = H*W*8;</div>
<div class="line">ptrdiff_t stride_h =   W*8;</div>
<div class="line">ptrdiff_t stride_w =     8;</div>
<div class="line"></div>
<div class="line">md.format_desc.blocking.strides = { <span class="comment">// strides between blocks</span></div>
<div class="line">    stride_n, stride_C, stride_h, stride_w</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">md.format_desc.inner_nblks = 1; <span class="comment">// number of blocked dimensions;</span></div>
<div class="line">                                <span class="comment">// 1, since only channels are blocked</span></div>
<div class="line"></div>
<div class="line">md.format_desc.inner_idxs[0] = 1; <span class="comment">// Only the 1st (c) dimension is blocked</span></div>
<div class="line">                                  <span class="comment">// n -- 0st dim, w -- 3rd dim</span></div>
<div class="line"></div>
<div class="line">md.format_desc.inner_blks[0] = 8; <span class="comment">// This 1st dimensions is blocked by 8</span></div>
</div><!-- fragment --><h3>What if channels are not a multiple of 8 (or 16)?</h3>
<p>The blocking data layout gives a significant performance improvement for the convolutions, but what to do when the number of channels is not a multiple of the block size (for example, 17 channels for <b>nChw8c</b> format)?</p>
<p>One of the possible ways to handle that would be to use blocked layout for as many channels as possible by rounding them down to a number that is a multiple of the block size (in this case <code>16 = 17 / 8 * 8</code>) and process the tail somehow. However, that would lead to the introduction of very special tail-processing code into many DNNL kernels.</p>
<p>So we came up with another solution using zero-padding. The idea is to round the channels up to make them multiples of the block size and pad the resulting tail with zeros (in the example above, <code>24 = div_up(17, 8) * 8</code>). Then primitives like convolutions might work with a rounded-up number of channels instead of the original ones and compute the correct result (adding zeros doesn't change the result).</p>
<p>That enables supporting an arbitrary number of channels with almost no changes to the kernels. The price would be some extra computations on those zeros, but either this is negligible or the performance with overheads is still higher than the performance with the plain data layout.</p>
<p>The picture below depicts the idea. Note that some extra computations occur during computation of <code>d0</code>, but that does not affect the result.</p>
<div class="image">
<img src="mem_fmt_padded_blk.png" alt="mem_fmt_padded_blk.png"/>
<div class="caption">
Padded format</div></div>
<p> Some pitfalls of the given approach:</p>
<ul>
<li>To keep <em>padded data are zeros</em> invariant, <a class="el" href="group__dnnl__api__memory.html#ga6888f8c17f272d6729c9bc258ed41fcf" title="Sets a memory object&#39;s data handle. ">dnnl_memory_set_data_handle()</a> and <a class="el" href="structdnnl_1_1memory.html#aaf3c13ed6f4af1b719ef7413ee36f63d" title="Sets memory buffer. ">dnnl::memory::set_data_handle()</a> physically add zeros whenever the user attaches a pointer to a memory that uses zero padding. That might affect performance if too many unnecessary calls to these functions are made. We might consider extending our API in the future to allow attaching pointers without subsequent initialization with zeros if the user can guarantee that the padding is already filled correctly.</li>
<li>The memory size required to keep the data cannot be computed by the formula <code>sizeof(data_type) * N * C * H * W</code> anymore. The actual size should always be queried via <a class="el" href="group__dnnl__api__memory.html#gaed039afa75d9f56763e2c1321f1563c4" title="Returns the size of a memory descriptor. ">dnnl_memory_desc_get_size()</a> in C and <a class="el" href="structdnnl_1_1memory_1_1desc.html#a3a12698f833b44ed55af9fc6621c4917" title="Returns size of the memory descriptor in bytes. ">dnnl::memory::desc::get_size()</a> in C++.</li>
<li>Element-wise operations that are implemented in the user's code and directly operate on DNNL blocked layout like this: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> e = 0; e &lt; phys_size; ++e)</div>
<div class="line">    x[e] = eltwise_op(x[e])</div>
</div><!-- fragment --> are not safe if the data is padded with zeros and <code>eltwise_op(0) != 0</code>.</li>
</ul>
<p>Relevant DNNL code: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> C = 17;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> C_padded = div_up(17, 8) * 8; <span class="comment">// 24</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// logical description, layout independent</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> ndims    = 4;            <span class="comment">// # of dimensions</span></div>
<div class="line"><a class="code" href="group__dnnl__api__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims = {N, C, H, W}; <span class="comment">// dimensions themselves</span></div>
<div class="line"></div>
<div class="line">memory_desc_t md;</div>
<div class="line"><span class="comment">// initialize memory descriptor</span></div>
<div class="line">dnnl_memory_desc_init(&amp;md, ndims,</div>
<div class="line">                             dims,</div>
<div class="line">                             <a class="code" href="group__dnnl__api__memory.html#gga012ba1c84ff24bdd068f9d2f9b26a130a6b33889946b183311c39cc1bd0656ae9">dnnl_f32</a>,   <span class="comment">// single precision data type</span></div>
<div class="line">                             <a class="code" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da775389dbdcda91ea12906210c309746f">dnnl_nChw8c</a> <span class="comment">// blocked layout</span></div>
<div class="line">                             );</div>
<div class="line"></div>
<div class="line">ptrdiff_t expect_stride_n = C_padded*H*W;   <span class="comment">// note C_padded here, not C</span></div>
<div class="line">ptrdiff_t expect_stride_C =          H*W*8;</div>
<div class="line">ptrdiff_t expect_stride_h =            W*8;</div>
<div class="line">ptrdiff_t expect_stride_w =              8;</div>
<div class="line">ptrdiff_t expect_stride_8c =             1;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> expect_true = <span class="keyword">true</span></div>
<div class="line">    &amp;&amp; <span class="keyword">true</span> <span class="comment">// logical dims stay as is</span></div>
<div class="line">    &amp;&amp; md.dims[0] == N</div>
<div class="line">    &amp;&amp; md.dims[1] == C</div>
<div class="line">    &amp;&amp; md.dims[2] == H</div>
<div class="line">    &amp;&amp; md.dims[3] == W</div>
<div class="line">    &amp;&amp; <span class="keyword">true</span> <span class="comment">// padded dims are rounded accordingly</span></div>
<div class="line">    &amp;&amp; md.padded_dims[0] == N</div>
<div class="line">    &amp;&amp; md.padded_dims[1] == C_padded</div>
<div class="line">    &amp;&amp; md.padded_dims[2] == H</div>
<div class="line">    &amp;&amp; md.padded_dims[3] == W</div>
<div class="line">    &amp;&amp; <span class="keyword">true</span> <span class="comment">// strides between blocks correspond to the physical layout</span></div>
<div class="line">    &amp;&amp; md.format_desc.blocking.strides[0] == expect_stride_n</div>
<div class="line">    &amp;&amp; md.format_desc.blocking.strides[1] == expect_stride_C</div>
<div class="line">    &amp;&amp; md.format_desc.blocking.strides[2] == expect_stride_h</div>
<div class="line">    &amp;&amp; md.format_desc.blocking.strides[3] == expect_stride_w</div>
<div class="line">    &amp;&amp; <span class="keyword">true</span> <span class="comment">// inner-most blocking</span></div>
<div class="line">    &amp;&amp; md.format_desc.blocking.inner_nblks == 1 <span class="comment">// only 1 dim is blocked (c)</span></div>
<div class="line">    &amp;&amp; md.format_desc.blocking.inner_idxs[0] == 1  <span class="comment">// 1st (c) dim is blocked</span></div>
<div class="line">    &amp;&amp; md.format_desc.blocking.inner_dims[0] == 8; <span class="comment">// the block size is 8</span></div>
<div class="line"></div>
<div class="line">assert(expect_true);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>