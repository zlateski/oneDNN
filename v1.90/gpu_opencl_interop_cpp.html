<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>DNNL: Getting started on GPU with OpenCL extensions API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Deep Neural Network Library (DNNL)
   &#160;<span id="projectnumber">1.90.1</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting started on GPU with OpenCL extensions API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>Full example text: <a class="el" href="gpu_opencl_interop_8cpp-example.html">gpu_opencl_interop.cpp</a></p>
<p>This C++ API example demonstrates programming for Intel(R) Processor Graphics with OpenCL* extensions API in DNNL. The workflow includes following steps:</p>
<ul>
<li>Create a GPU engine. It uses OpenCL as the runtime in this sample.</li>
<li>Create a GPU memory descriptor/object.</li>
<li>Create an OpenCL kernel for GPU data initialization</li>
<li>Access a GPU memory via OpenCL interoperability interface</li>
<li>Access a GPU command queue via OpenCL interoperability interface</li>
<li>Execute a OpenCL kernel with related GPU command queue and GPU memory</li>
<li>Create operation descriptor/operation primitives descriptor/primitive .</li>
<li>Execute the primitive with the initialized GPU memory</li>
<li>Validate the result by mapping the OpenCL memory via OpenCL interoperability interface</li>
</ul>
<h1><a class="anchor" id="gpu_opencl_interop_cpp_headers"></a>
Public headers</h1>
<p>To start using DNNL, we must first include the <a class="el" href="dnnl_8hpp.html">dnnl.hpp</a> header file in the application. We also include CL/cl.h for using OpenCL APIs and <a class="el" href="dnnl__debug_8h.html">dnnl_debug.h</a>, which contains some debugging facilities such as returning a string representation for common DNNL C types. All C++ API types and functions reside in the <code>dnnl</code> namespace. For simplicity of the example we import this namespace.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dnnl_8hpp.html">dnnl.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CL/cl.h&gt;</span></div>
<div class="line"><span class="comment">// Optional header to access debug functions like `dnnl_status2str()`</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dnnl__debug_8h.html">dnnl_debug.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>dnnl;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
</div><!-- fragment --> <h1><a class="anchor" id="gpu_opencl_interop_cpp_tutorial"></a>
gpu_opencl_interop_tutorial() function</h1>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub1"></a>
Engine and stream</h2>
<p>All DNNL primitives and memory objects are attached to a particular <a class="el" href="structdnnl_1_1engine.html">dnnl::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device to which they are attached, and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create engines, we must specify the <a class="el" href="structdnnl_1_1engine.html#a2635da16314dcbdb9bd9ea431316bb1a">dnnl::engine::kind</a> and the index of the device of the given kind. In this example we use the first available GPU engine, so the index for the engine is 0. This example assumes OpenCL being a runtime for GPU. In such case, during engine creation, an OpenCL context is also created and attaches to the created engine.</p>
<div class="fragment"><div class="line">    engine eng(engine::kind::gpu, 0);</div>
</div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structdnnl_1_1stream.html">dnnl::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>In this example, a GPU stream is created. This example assumes OpenCL being a runtime for GPU. During stream creation, an OpenCL command queue is also created and attaches to this stream.</p>
<div class="fragment"><div class="line">    <a class="code" href="structdnnl_1_1stream.html">dnnl::stream</a> strm(eng);</div>
</div><!-- fragment --> <h2><a class="anchor" id="gpu_opencl_interop_cpp_sub2"></a>
Wrapping data into DNNL memory object</h2>
<p>Next, we create a memory object. We need to specify dimensions of our memory by passing a memory::dims object. Then we create a memory descriptor with these dimensions, with the <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dcea512dc597be7ae761876315165dc8bd2e" title="32-bit/single-precision floating point. ">dnnl::memory::data_type::f32</a> data type, and with the <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3faded7ac40158367123c5467281d44cbeb" title="4D CNN activations tensor, an alias to dnnl::memory::format_tag::abcd ">dnnl::memory::format_tag::nchw</a> memory format. Finally, we construct a memory object and pass the memory descriptor. The library allocates memory internally. </p>
<div class="fragment"><div class="line">    memory::dims tz_dims = {2, 3, 4, 5};</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> N = std::accumulate(tz_dims.begin(), tz_dims.end(), (size_t)1,</div>
<div class="line">            std::multiplies&lt;size_t&gt;());</div>
<div class="line"></div>
<div class="line">    memory::desc mem_d(</div>
<div class="line">            tz_dims, memory::data_type::f32, memory::format_tag::nchw);</div>
<div class="line"></div>
<div class="line">    memory mem(mem_d, eng);</div>
</div><!-- fragment --> <h2><a class="anchor" id="gpu_opencl_interop_cpp_sub3"></a>
Initialize the data by executing a custom OpenCL kernel</h2>
<p>We are going to create an OpenCL kernel that will initialize our data. It requires writing a bit of C code to create an OpenCL program from a string literal source. The kernel initializes the data by the 0, -1, 2, -3, ... sequence: <code>data[i] = (-1)^i * i</code>. </p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *ocl_code</div>
<div class="line">            = <span class="stringliteral">&quot;__kernel void init(__global float *data) {&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;    int id = get_global_id(0);&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;    data[id] = (id % 2) ? -id : id;&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;}&quot;</span>;</div>
</div><!-- fragment --><p> Create/Build Opencl kernel by <code>create_init_opencl_kernel()</code> function. Refer to the full code example for the <code>create_init_opencl_kernel()</code> function. </p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name = <span class="stringliteral">&quot;init&quot;</span>;</div>
<div class="line">    cl_kernel ocl_init_kernel = create_init_opencl_kernel(</div>
<div class="line">            eng.get_ocl_context(), kernel_name, ocl_code);</div>
</div><!-- fragment --><p> The next step is to execute our OpenCL kernel by setting its arguments and enqueueing to an OpenCL queue. You can extract the underlying OpenCL buffer from the memory object using the interoperability interface: dnnl::memory::get_ocl_mem_object() . For simplicity we can just construct a stream, extract the underlying OpenCL queue, and enqueue the kernel to this queue. </p>
<div class="fragment"><div class="line">    cl_mem ocl_buf = mem.get_ocl_mem_object();</div>
<div class="line">    OCL_CHECK(clSetKernelArg(ocl_init_kernel, 0, <span class="keyword">sizeof</span>(ocl_buf), &amp;ocl_buf));</div>
<div class="line"></div>
<div class="line">    cl_command_queue ocl_queue = strm.get_ocl_command_queue();</div>
<div class="line">    OCL_CHECK(clEnqueueNDRangeKernel(ocl_queue, ocl_init_kernel, 1, <span class="keyword">nullptr</span>, &amp;N,</div>
<div class="line">            <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>));</div>
</div><!-- fragment --> <h2><a class="anchor" id="gpu_opencl_interop_cpp_sub4"></a>
Create and execute a primitive</h2>
<p>There are three steps to create an operation primitive in DNNL:</p>
<ol type="1">
<li>Create an operation descriptor.</li>
<li>Create a primitive descriptor.</li>
<li>Create a primitive.</li>
</ol>
<p>Let's create the primitive to perform the ReLU (rectified linear unit) operation: x = max(0, x). An operation descriptor has no dependency on a specific engine - it just describes some operation. On the contrary, primitive descriptors are attached to a specific engine and represent some implementation for this engine. A primitive object is a realization of a primitive descriptor, and its construction is usually much "heavier". </p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(</div>
<div class="line">            prop_kind::forward, algorithm::eltwise_relu, mem_d, 0.0f);</div>
<div class="line">    <span class="keyword">auto</span> relu_pd = eltwise_forward::primitive_desc(relu_d, eng);</div>
<div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd);</div>
</div><!-- fragment --><p> Next, execute the primitive. </p>
<div class="fragment"><div class="line">    relu.execute(strm, {{DNNL_ARG_SRC, mem}, {DNNL_ARG_DST, mem}});</div>
<div class="line">    strm.wait();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Our primitive mem serves as both input and output parameter.</dd>
<dd>
Primitive submission on GPU is asynchronous; However, the user can call dnnl:stream::wait() to synchronize the stream and ensure that all previously submitted primitives are completed.</dd></dl>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub5"></a>
Validate the results</h2>
<p>Before running validation codes, we need to access the OpenCL memory on the host. The simplest way to access the OpenCL memory is to map it to the host using the dnnl::memory::map_data() and dnnl::memory::unmap_data() APIs. After mapping, this data is directly accessible for reading or writing on the host. We can run validation codes on the host accordingly. While the data is mapped, no GPU-side operations on this data are allowed. The data should be unmapped to release all resources associated with mapping. </p>
<div class="fragment"><div class="line">    <span class="keywordtype">float</span> *mapped_data = mem.map_data&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; i++) {</div>
<div class="line">        <span class="keywordtype">float</span> expected = (i % 2) ? 0.0f : (<span class="keywordtype">float</span>)i;</div>
<div class="line">        <span class="keywordflow">if</span> (mapped_data[i] != expected)</div>
<div class="line">            <span class="keywordflow">throw</span> std::string(</div>
<div class="line">                    <span class="stringliteral">&quot;Unexpected output, find a negative value after the ReLU &quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;execution&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    mem.unmap_data(mapped_data);</div>
</div><!-- fragment --> <h1><a class="anchor" id="gpu_opencl_interop_cpp_main"></a>
main() function</h1>
<p>We now just call everything we prepared earlier.</p>
<p>Because we are using the DNNL C++ API, we use exceptions to handle errors (see <a class="el" href="dev_guide_c_and_cpp_apis.html">C and C++ APIs</a>). The DNNL C++ API throws exceptions of type <a class="el" href="structdnnl_1_1error.html">dnnl::error</a>, which contains the error status (of type <a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a>) and a human-readable error message accessible through the regular <code>what()</code> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        gpu_opencl_interop_tutorial();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="structdnnl_1_1error.html">dnnl::error</a> &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;DNNL error: &quot;</span> &lt;&lt; e.<a class="code" href="structdnnl_1_1error.html#adfc1a2bf4e31aa1751b38e8e1dbcba2b">what</a>() &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Error status: &quot;</span> &lt;&lt; dnnl_status2str(e.status) &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">catch</span> (std::string &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error in the example: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Example passes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and running the example, the output should be just:</p>
<div class="fragment"><div class="line">Example passes</div>
</div><!-- fragment --> </div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>