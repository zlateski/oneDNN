<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>oneDNN: dnnl::memory::desc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">oneAPI Deep Neural Network Library (oneDNN)
   &#160;<span id="projectnumber">1.94.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacednnl.html">dnnl</a></li><li class="navelem"><a class="el" href="structdnnl_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structdnnl_1_1memory_1_1desc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dnnl::memory::desc Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A memory descriptor.  
 <a href="structdnnl_1_1memory_1_1desc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dnnl_8hpp_source.html">dnnl.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dnnl::memory::desc:</div>
<div class="dyncontent">
<div class="center"><img src="structdnnl_1_1memory_1_1desc__coll__graph.png" border="0" usemap="#dnnl_1_1memory_1_1desc_coll__map" alt="Collaboration graph"/></div>
<map name="dnnl_1_1memory_1_1desc_coll__map" id="dnnl_1_1memory_1_1desc_coll__map">
<area shape="rect" id="node2" href="structdnnl__memory__desc__t.html" title="Memory descriptor. " alt="" coords="344,81,491,108"/><area shape="rect" id="node3" href="structdnnl__wino__desc__t.html" title="Description of tensor of weights for winograd 2x3 convolution. " alt="" coords="34,5,161,32"/><area shape="rect" id="node4" href="structdnnl__blocking__desc__t.html" title="Generic description of blocked data layout for most memory formats. " alt="" coords="24,56,171,83"/><area shape="rect" id="node5" href="structdnnl__rnn__packed__desc__t.html" title="Description of tensor of packed weights for rnn. " alt="" coords="14,107,181,133"/><area shape="rect" id="node6" href="structdnnl__memory__extra__desc__t.html" title="Description of extra information stored in memory. " alt="" coords="6,157,189,184"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a12f9b43aae8c214d695b321b543b5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a2a12f9b43aae8c214d695b321b543b5c">desc</a> ()</td></tr>
<tr class="memdesc:a2a12f9b43aae8c214d695b321b543b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a zero (empty) memory descriptor.  <a href="#a2a12f9b43aae8c214d695b321b543b5c">More...</a><br/></td></tr>
<tr class="separator:a2a12f9b43aae8c214d695b321b543b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8efdb0761b98bfe82d71786a4e1d39e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#af8efdb0761b98bfe82d71786a4e1d39e">desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;<a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a>, <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a> <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>, <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">format_tag</a> <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">format_tag</a>, bool allow_empty=false)</td></tr>
<tr class="memdesc:af8efdb0761b98bfe82d71786a4e1d39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor.  <a href="#af8efdb0761b98bfe82d71786a4e1d39e">More...</a><br/></td></tr>
<tr class="separator:af8efdb0761b98bfe82d71786a4e1d39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37dd11b790b39442c29cd74ea75a166"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#aa37dd11b790b39442c29cd74ea75a166">desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;<a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a>, <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a> <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>, const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;strides, bool allow_empty=false)</td></tr>
<tr class="memdesc:aa37dd11b790b39442c29cd74ea75a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by strides.  <a href="#aa37dd11b790b39442c29cd74ea75a166">More...</a><br/></td></tr>
<tr class="separator:aa37dd11b790b39442c29cd74ea75a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#adc5a3eb4dbd8aef650bf6823f13167e3">desc</a> (const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> &amp;<a class="el" href="structdnnl_1_1memory_1_1desc.html#afea646e8777c2341509a61f4ae17dcf3">data</a>)</td></tr>
<tr class="memdesc:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor from a C API data structure.  <a href="#adc5a3eb4dbd8aef650bf6823f13167e3">More...</a><br/></td></tr>
<tr class="separator:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d017ecf635aae91cc3856a9dfe0721c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a3d017ecf635aae91cc3856a9dfe0721c">submemory_desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;<a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a>, const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;offsets, bool allow_empty=false) const </td></tr>
<tr class="memdesc:a3d017ecf635aae91cc3856a9dfe0721c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor for a region inside an area described by this memory descriptor.  <a href="#a3d017ecf635aae91cc3856a9dfe0721c">More...</a><br/></td></tr>
<tr class="separator:a3d017ecf635aae91cc3856a9dfe0721c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0325f155fdaf54443a31df5bd7a1ab88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a0325f155fdaf54443a31df5bd7a1ab88">reshape</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;<a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a>, bool allow_empty=false) const </td></tr>
<tr class="memdesc:a0325f155fdaf54443a31df5bd7a1ab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by reshaping an existing one.  <a href="#a0325f155fdaf54443a31df5bd7a1ab88">More...</a><br/></td></tr>
<tr class="separator:a0325f155fdaf54443a31df5bd7a1ab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8e97d94b247910fcf2473da12844d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a9dd8e97d94b247910fcf2473da12844d">permute_axes</a> (const std::vector&lt; int &gt; &amp;permutation, bool allow_empty=false) const </td></tr>
<tr class="memdesc:a9dd8e97d94b247910fcf2473da12844d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by permuting axes in an existing one.  <a href="#a9dd8e97d94b247910fcf2473da12844d">More...</a><br/></td></tr>
<tr class="separator:a9dd8e97d94b247910fcf2473da12844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d7a286f274fc21a0202e678fb06e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a491d7a286f274fc21a0202e678fb06e9">dims</a> () const </td></tr>
<tr class="memdesc:a491d7a286f274fc21a0202e678fb06e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dimensions of the memory descriptor.  <a href="#a491d7a286f274fc21a0202e678fb06e9">More...</a><br/></td></tr>
<tr class="separator:a491d7a286f274fc21a0202e678fb06e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a55bc177f0397a337222c3de6fd102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">memory::data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a13a55bc177f0397a337222c3de6fd102">data_type</a> () const </td></tr>
<tr class="memdesc:a13a55bc177f0397a337222c3de6fd102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data type of the memory descriptor.  <a href="#a13a55bc177f0397a337222c3de6fd102">More...</a><br/></td></tr>
<tr class="separator:a13a55bc177f0397a337222c3de6fd102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a12698f833b44ed55af9fc6621c4917"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a3a12698f833b44ed55af9fc6621c4917">get_size</a> () const </td></tr>
<tr class="memdesc:a3a12698f833b44ed55af9fc6621c4917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of the memory descriptor in bytes.  <a href="#a3a12698f833b44ed55af9fc6621c4917">More...</a><br/></td></tr>
<tr class="separator:a3a12698f833b44ed55af9fc6621c4917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517663e910e8c1795b3a935f49579652"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a517663e910e8c1795b3a935f49579652">is_zero</a> () const </td></tr>
<tr class="memdesc:a517663e910e8c1795b3a935f49579652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the memory descriptor is zero (empty).  <a href="#a517663e910e8c1795b3a935f49579652">More...</a><br/></td></tr>
<tr class="separator:a517663e910e8c1795b3a935f49579652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4cd7dfcc61b101ff1b82927cd6c16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a16d4cd7dfcc61b101ff1b82927cd6c16">operator==</a> (const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;other) const </td></tr>
<tr class="memdesc:a16d4cd7dfcc61b101ff1b82927cd6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equality operator.  <a href="#a16d4cd7dfcc61b101ff1b82927cd6c16">More...</a><br/></td></tr>
<tr class="separator:a16d4cd7dfcc61b101ff1b82927cd6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e2e2af3d52c3812cc73493726091ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#ac4e2e2af3d52c3812cc73493726091ab">operator!=</a> (const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;other) const </td></tr>
<tr class="memdesc:ac4e2e2af3d52c3812cc73493726091ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inequality operator.  <a href="#ac4e2e2af3d52c3812cc73493726091ab">More...</a><br/></td></tr>
<tr class="separator:ac4e2e2af3d52c3812cc73493726091ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afea646e8777c2341509a61f4ae17dcf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea646e8777c2341509a61f4ae17dcf3"></a>
<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#afea646e8777c2341509a61f4ae17dcf3">data</a></td></tr>
<tr class="memdesc:afea646e8777c2341509a61f4ae17dcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C API data structure. <br/></td></tr>
<tr class="separator:afea646e8777c2341509a61f4ae17dcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A memory descriptor. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="batch_normalization_8cpp-example.html#_a4">batch_normalization.cpp</a>, <a class="el" href="binary_8cpp-example.html#_a4">binary.cpp</a>, <a class="el" href="cnn_inference_f32_8cpp-example.html#_a5">cnn_inference_f32.cpp</a>, <a class="el" href="cnn_inference_int8_8cpp-example.html#_a5">cnn_inference_int8.cpp</a>, <a class="el" href="cnn_training_f32_8cpp-example.html#_a5">cnn_training_f32.cpp</a>, <a class="el" href="concat_8cpp-example.html#_a4">concat.cpp</a>, <a class="el" href="convolution_8cpp-example.html#_a5">convolution.cpp</a>, <a class="el" href="cpu_cnn_training_bf16_8cpp-example.html#_a6">cpu_cnn_training_bf16.cpp</a>, <a class="el" href="cpu_matmul_quantization_8cpp-example.html#_a5">cpu_matmul_quantization.cpp</a>, <a class="el" href="cpu_rnn_inference_f32_8cpp-example.html#_a5">cpu_rnn_inference_f32.cpp</a>, <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html#_a6">cpu_rnn_inference_int8.cpp</a>, <a class="el" href="cpu_sgemm_and_matmul_8cpp-example.html#_a4">cpu_sgemm_and_matmul.cpp</a>, <a class="el" href="eltwise_8cpp-example.html#_a4">eltwise.cpp</a>, <a class="el" href="getting_started_8cpp-example.html#_a2">getting_started.cpp</a>, <a class="el" href="gpu_opencl_interop_8cpp-example.html#_a3">gpu_opencl_interop.cpp</a>, <a class="el" href="inference_int8_matmul_8cpp-example.html#_a3">inference_int8_matmul.cpp</a>, <a class="el" href="inner_product_8cpp-example.html#_a4">inner_product.cpp</a>, <a class="el" href="layer_normalization_8cpp-example.html#_a4">layer_normalization.cpp</a>, <a class="el" href="logsoftmax_8cpp-example.html#_a4">logsoftmax.cpp</a>, <a class="el" href="lrn_8cpp-example.html#_a4">lrn.cpp</a>, <a class="el" href="lstm_8cpp-example.html#_a4">lstm.cpp</a>, <a class="el" href="matmul_8cpp-example.html#_a4">matmul.cpp</a>, <a class="el" href="memory_format_propagation_8cpp-example.html#_a2">memory_format_propagation.cpp</a>, <a class="el" href="performance_profiling_8cpp-example.html#_a14">performance_profiling.cpp</a>, <a class="el" href="pooling_8cpp-example.html#_a4">pooling.cpp</a>, <a class="el" href="reorder_8cpp-example.html#_a4">reorder.cpp</a>, <a class="el" href="resampling_8cpp-example.html#_a4">resampling.cpp</a>, <a class="el" href="rnn_training_f32_8cpp-example.html#_a7">rnn_training_f32.cpp</a>, <a class="el" href="shuffle_8cpp-example.html#_a4">shuffle.cpp</a>, <a class="el" href="softmax_8cpp-example.html#_a4">softmax.cpp</a>, <a class="el" href="sum_8cpp-example.html#_a4">sum.cpp</a>, and <a class="el" href="sycl_interop_8cpp-example.html#_a2">sycl_interop.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2a12f9b43aae8c214d695b321b543b5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a zero (empty) memory descriptor. </p>
<p>Such a memory descriptor can be used to indicate absence of an argument. </p>

</div>
</div>
<a class="anchor" id="af8efdb0761b98bfe82d71786a4e1d39e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">format_tag</a>&#160;</td>
          <td class="paramname"><em>format_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor. </p>
<dl class="section note"><dt>Note</dt><dd>The logical order of dimensions corresponds to the <code>abc...</code> format tag, and the physical meaning of the dimensions depends both on the primitive that would operate on this memory and the operation context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Tensor dimensions. </td></tr>
    <tr><td class="paramname">data_type</td><td>Data precision/type. </td></tr>
    <tr><td class="paramname">format_tag</td><td>Memory format tag. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be constructed. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa37dd11b790b39442c29cd74ea75a166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by strides. </p>
<dl class="section note"><dt>Note</dt><dd>The logical order of dimensions corresponds to the <code>abc...</code> format tag, and the physical meaning of the dimensions depends both on the primitive that would operate on this memory and the operation context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Tensor dimensions. </td></tr>
    <tr><td class="paramname">data_type</td><td>Data precision/type. </td></tr>
    <tr><td class="paramname">strides</td><td>Strides for each dimension. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be constructed. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc5a3eb4dbd8aef650bf6823f13167e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor from a C API data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A C API <a class="el" href="structdnnl__memory__desc__t.html" title="Memory descriptor. ">dnnl_memory_desc_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3d017ecf635aae91cc3856a9dfe0721c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::submemory_desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor for a region inside an area described by this memory descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Sizes of the region. </td></tr>
    <tr><td class="paramname">offsets</td><td>Offsets to the region from the encompassing memory object in each dimension. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A memory descriptor for the region. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cpu_rnn_inference_f32_8cpp-example.html#a28">cpu_rnn_inference_f32.cpp</a>, and <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html#a43">cpu_rnn_inference_int8.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0325f155fdaf54443a31df5bd7a1ab88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by reshaping an existing one. </p>
<p>The new memory descriptor inherits the data type. This operation is valid only for memory descriptors that have format_kind set to <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa61326117ed4a9ddf3f754e71e119e5b3" title="A tensor in a generic format described by the stride and blocking values in each dimension. ">dnnl::memory::format_kind::blocked</a> or <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa100b8cad7cf2a56f6df78f171f97a1ec" title="Unspecified format kind. ">dnnl::memory::format_kind::any</a>.</p>
<p>The operation ensures that the transformation of the physical memory format corresponds to the transformation of the logical dimensions. If such transformation is impossible, the function either throws an exception (default) or returns a zero memory descriptor depending on the <code>allow_empty</code> flag.</p>
<p>The reshape operation can be described as a combination of the following basic operations:</p>
<ol type="1">
<li>Add a dimension of size <code>1</code>. This is always possible.</li>
<li>Remove a dimension of size <code>1</code>. This is possible only if the dimension has no padding (i.e. <code>padded_dims[dim] == dims[dim] &amp;&amp; dims[dim] == 1</code>).</li>
<li>Split a dimension into multiple ones. This is possible only if the size of the dimension is exactly equal to the product of the split ones and the dimension does not have padding (i.e. <code>padded_dims[dim] = dims[dim]</code>).</li>
<li>Joining multiple consecutive dimensions into a single one. As in the cases above, this requires that the dimensions do not have padding and that the memory format is such that in physical memory these dimensions are dense and have the same order as their logical counterparts. This also assumes that these dimensions are not blocked.<ul>
<li>Here, dense means: <code>stride for dim[i] == (stride for dim[i + 1]) * dim[i + 1]</code>;</li>
<li>And same order means: <code>i &lt; j</code> if and only if <code>stride for dim[j] &lt;= stride for dim[i]</code>.</li>
</ul>
</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Some combinations of physical memory layout and/or offsets or dimensions may result in a failure to make a reshape.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>New dimensions. The product of dimensions must remain constant. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new memory descriptor with new dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dd8e97d94b247910fcf2473da12844d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::permute_axes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by permuting axes in an existing one. </p>
<p>The physical memory layout representation is adjusted accordingly to maintain the consistency between the logical and physical parts of the memory descriptor.</p>
<p>The new memory descriptor inherits the data type. This operation is valid only for memory descriptors that have format_kind set to <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa61326117ed4a9ddf3f754e71e119e5b3" title="A tensor in a generic format described by the stride and blocking values in each dimension. ">dnnl::memory::format_kind::blocked</a> or <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa100b8cad7cf2a56f6df78f171f97a1ec" title="Unspecified format kind. ">dnnl::memory::format_kind::any</a>.</p>
<p>The logical axes will be permuted in the following manner: </p>
<div class="fragment"><div class="line">*  <span class="keywordflow">for</span> (i = 0; i &lt; ndims(); i++)</div>
<div class="line">*      new_desc.dims()[permutation[i]] = <a class="code" href="structdnnl_1_1memory_1_1desc.html#a491d7a286f274fc21a0202e678fb06e9">dims</a>()[i];</div>
<div class="line">*  </div>
</div><!-- fragment --><p>Example: </p>
<div class="fragment"><div class="line">*      std::vector&lt;int&gt; permutation = {1, 0}; <span class="comment">// swap the first and</span></div>
<div class="line">*                                             <span class="comment">// the second axes</span></div>
<div class="line">*      <a class="code" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a> in_md(</div>
<div class="line">*              {2, 3}, <a class="code" href="structdnnl_1_1memory_1_1desc.html#a13a55bc177f0397a337222c3de6fd102">data_type</a>, <a class="code" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa187ef4436122d1cc2f40dc2b92f0eba0">memory::format_tag::ab</a>);</div>
<div class="line">*      <a class="code" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a> expect_out_md(</div>
<div class="line">*              {3, 2}, <a class="code" href="structdnnl_1_1memory_1_1desc.html#a13a55bc177f0397a337222c3de6fd102">data_type</a>, <a class="code" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa07159c47ee1b19ae4fb9c40d480856c4">memory::format_tag::ba</a>);</div>
<div class="line">* </div>
<div class="line">*      assert(in_md.permute_axes(permutation) == expect_out_md);</div>
<div class="line">*  </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutation</td><td>Axes permutation. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new memory descriptor with new dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="a491d7a286f274fc21a0202e678fb06e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> dnnl::memory::desc::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns dimensions of the memory descriptor. </p>
<p>Potentially expensive due to the data copy involved. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the dimensions vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a13a55bc177f0397a337222c3de6fd102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">memory::data_type</a> dnnl::memory::desc::data_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data type of the memory descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>The data type. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a12698f833b44ed55af9fc6621c4917"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dnnl::memory::desc::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of the memory descriptor in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes required to allocate a memory buffer for the memory object described by this memory descriptor including the padding area. </dd></dl>

</div>
</div>
<a class="anchor" id="a517663e910e8c1795b3a935f49579652"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the memory descriptor is zero (empty). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the memory descriptor describes an empty memory and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a16d4cd7dfcc61b101ff1b82927cd6c16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another memory descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and the other memory descriptors have the same format tag, dimensions, strides, blocking, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4e2e2af3d52c3812cc73493726091ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another memory descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and the other memory descriptors describe different memory. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="dnnl_8hpp_source.html">dnnl.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>