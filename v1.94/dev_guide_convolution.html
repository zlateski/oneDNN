<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>oneDNN: Convolution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">oneAPI Deep Neural Network Library (oneDNN)
   &#160;<span id="projectnumber">1.94.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Convolution </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p></p>
<p><a class="el" href="group__dnnl__api__convolution.html">API Reference</a></p>
<p></p>
</blockquote>
<p>The convolution primitive computes forward, backward, or weight update for a batched convolution operation on 1D, 2D, or 3D spatial data with bias.</p>
<p>The convolution operation is defined by the following formulas. We show formulas only for 2D spatial data which are straightforward to generalize to cases of higher and lower dimensions. Variable names follow the standard <a class="el" href="dev_guide_conventions.html">Naming Conventions</a>.</p>
<p>Let \(\src\), \(\weights\) and \(\dst\) be \(N \times IC \times IH \times IW\), \(OC \times IC \times KH \times KW\), and \(N \times OC \times OH \times OW\) tensors respectively. Let \(\bias\) be a 1D tensor with \(OC\) elements.</p>
<p>Furthermore, let the remaining convolution parameters be:</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th align="left">Depth </th><th align="left">Height </th><th align="left">Width </th><th align="left">Comment  </th></tr>
<tr>
<td>Padding: <br/>
Front, top, and left </td><td align="left">\(PD_L\) </td><td align="left">\(PH_L\) </td><td align="left">\(PW_L\) </td><td align="left">In the API we use <code>padding_l</code> to indicate the corresponding vector of paddings (<code>_l</code> in the name stands for <b>left</b>) </td></tr>
<tr>
<td>Padding: <br/>
Back, bottom, and right </td><td align="left">\(PD_R\) </td><td align="left">\(PH_R\) </td><td align="left">\(PW_R\) </td><td align="left">In the API we use <code>padding_r</code> to indicate the corresponding vector of paddings (<code>_r</code> in the name stands for <b>right</b>) </td></tr>
<tr>
<td>Stride </td><td align="left">\(SD\) </td><td align="left">\(SH\) </td><td align="left">\(SW\) </td><td align="left">Non-strided convolution should have the stride parameters equal <code>1</code> </td></tr>
<tr>
<td>Dilation </td><td align="left">\(DD\) </td><td align="left">\(DH\) </td><td align="left">\(DW\) </td><td align="left">Dilation starts with 0, so non-dilated convolution should have the dilation parameters equal <code>0</code> </td></tr>
</table>
<p>The following formulas show how oneDNN computes convolutions. They are broken down into several types to simplify the exposition, but in reality the convolution types can be combined.</p>
<p>To further simplify the formulas, we assume that \(\src(n, ic, ih, iw) = 0\) if \(ih &lt; 0\), or \(ih \geq IH\), or \(iw &lt; 0\), or \(iw \geq IW\).</p>
<h3>Forward</h3>
<h4>Regular Convolution</h4>
<p class="formulaDsp">
\[\dst(n, oc, oh, ow) = \bias(oc) + \\ + \sum_{ic=0}^{IC-1}\sum_{kh=0}^{KH-1}\sum_{kw=0}^{KW-1} \src(n, ic, oh \cdot SH + kh - PH_L, ow \cdot SW + kw - PW_L) \cdot \weights(oc, ic, kh, kw).\]
</p>
<p>Here:</p>
<ul>
<li>\(OH = \left\lfloor{\frac{IH - KH + PH_L + PH_R}{SH}} \right\rfloor + 1,\)</li>
<li>\(OW = \left\lfloor{\frac{IW - KW + PW_L + PW_R}{SW}} \right\rfloor + 1.\)</li>
</ul>
<h4>Convolution with Groups</h4>
<p>In the API, oneDNN adds a separate groups dimension to memory objects representing \(\weights\) tensors and represents weights as \(G \times OC_G \times IC_G \times KH \times KW \) 5D tensors for 2D convolutions with groups.</p>
<p class="formulaDsp">
\[ \dst(n, g \cdot OC_G + oc_g, oh, ow) = \bias(g \cdot OC_G + oc_g) + \\ + \sum_{ic_g=0}^{IC_G-1}\sum_{kh=0}^{KH-1}\sum_{kw=0}^{KW-1} \src(n, g \cdot IC_G + ic_g, oh + kh - PH_L, ow + kw - PW_L) \cdot \weights(g, oc_g, ic_g, kh, kw), \]
</p>
<p>where</p>
<ul>
<li>\(IC_G = \frac{IC}{G}\),</li>
<li>\(OC_G = \frac{OC}{G}\), and</li>
<li>\(oc_g \in [0, OC_G).\)</li>
</ul>
<p>The case when \(OC_G = IC_G = 1\) is also known as <em>a depthwise convolution</em>.</p>
<h4>Convolution with Dilation</h4>
<p class="formulaDsp">
\[ \dst(n, oc, oh, ow) = \bias(oc) + \\ + \sum_{ic=0}^{IC-1}\sum_{kh=0}^{KH-1}\sum_{kw=0}^{KW-1} \src(n, ic, oh + kh \cdot (DH + 1) - PH_L, ow + kw \cdot (DW + 1) - PW_L) \cdot \weights(oc, ic, kh, kw). \]
</p>
<p>Here:</p>
<ul>
<li>\(OH = \left\lfloor{\frac{IH - DKH + PH_L + PH_R}{SH}} \right\rfloor + 1,\) where \(DKH = 1 + (KH - 1) \cdot (DH + 1)\), and</li>
<li>\(OW = \left\lfloor{\frac{IW - DKW + PW_L + PW_R}{SW}} \right\rfloor + 1,\) where \(DKW = 1 + (KW - 1) \cdot (DW + 1)\).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In oneDNN dilation parameter equals 0 corresponds to non-dilated, i.e. regular, convolution. Other libraries might use another convention, where dilation parameter equals 1 corresponds to regular convolution.</dd></dl>
<h4>Deconvolution (Transposed Convolution)</h4>
<p>Deconvolutions (also called fractionally strided convolutions or transposed convolutions) work by swapping the forward and backward passes of a convolution. One way to put it is to note that the weights define a convolution, but whether it is a direct convolution or a transposed convolution is determined by how the forward and backward passes are computed.</p>
<h4>Difference Between Forward Training and Forward Inference</h4>
<p>There is no difference between the <a class="el" href="group__dnnl__api__primitives__common.html#ggae3c1f22ae55645782923fbfd8b07d0c4a992e03bebfe623ac876b3636333bbce0" title="Forward data propagation (training mode). ">dnnl_forward_training</a> and <a class="el" href="group__dnnl__api__primitives__common.html#ggae3c1f22ae55645782923fbfd8b07d0c4a2f77a568a675dec649eb0450c997856d" title="Forward data propagation (inference mode). ">dnnl_forward_inference</a> propagation kinds.</p>
<h3>Backward</h3>
<p>The backward propagation computes \(\diffsrc\) based on \(\diffdst\) and \(\weights\).</p>
<p>The weights update computes \(\diffweights\) and \(\diffbias\) based on \(\diffdst\) and \(\src\).</p>
<dl class="section note"><dt>Note</dt><dd>The <em>optimized</em> memory formats \(\src\) and \(\weights\) might be different on forward propagation, backward propagation, and weights update.</dd></dl>
<h2>Execution Arguments</h2>
<p>When executed, the inputs and outputs should be mapped to an execution argument index as specified by the following table. </p>
<table class="doxtable">
<tr>
<th>Primitive input/output </th><th>Execution argument index  </th></tr>
<tr>
<td>\(\src\) </td><td>DNNL_ARG_SRC </td></tr>
<tr>
<td>\(\weights\) </td><td>DNNL_ARG_WEIGHTS </td></tr>
<tr>
<td>\(\bias\) </td><td>DNNL_ARG_BIAS </td></tr>
<tr>
<td>\(\dst\) </td><td>DNNL_ARG_DST </td></tr>
<tr>
<td>\(\diffsrc\) </td><td>DNNL_ARG_DIFF_SRC </td></tr>
<tr>
<td>\(\diffweights\) </td><td>DNNL_ARG_DIFF_WEIGHTS </td></tr>
<tr>
<td>\(\diffbias\) </td><td>DNNL_ARG_DIFF_BIAS </td></tr>
<tr>
<td>\(\diffdst\) </td><td>DNNL_ARG_DIFF_DST </td></tr>
<tr>
<td>\(depthwise\) </td><td>DNNL_ARG_ATTR_POST_OP_DW </td></tr>
</table>
<h2>Implementation Details</h2>
<h3>General Notes</h3>
<p>N/A.</p>
<h3>Data Types</h3>
<p>Convolution primitive supports the following combination of data types for source, destination, and weights memory objects:</p>
<table class="doxtable">
<tr>
<th align="left">Propagation </th><th align="left">Source </th><th align="left">Weights </th><th align="left">Destination </th><th align="left">Bias  </th></tr>
<tr>
<td align="left">forward / backward </td><td align="left">f32 </td><td align="left">f32 </td><td align="left">f32 </td><td align="left">f32 </td></tr>
<tr>
<td align="left">forward </td><td align="left">f16 </td><td align="left">f16 </td><td align="left">f16 </td><td align="left">f16 </td></tr>
<tr>
<td align="left">forward </td><td align="left">u8, s8 </td><td align="left">s8 </td><td align="left">u8, s8, s32, f32 </td><td align="left">u8, s8, s32, f32 </td></tr>
<tr>
<td align="left">forward </td><td align="left">bf16 </td><td align="left">bf16 </td><td align="left">f32, bf16 </td><td align="left">f32, bf16 </td></tr>
<tr>
<td align="left">backward </td><td align="left">f32, bf16 </td><td align="left">bf16 </td><td align="left">bf16 </td><td align="left"></td></tr>
<tr>
<td align="left">weights update </td><td align="left">bf16 </td><td align="left">f32, bf16 </td><td align="left">bf16 </td><td align="left">f32, bf16 </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>There might be hardware and/or implementation specific restrictions. Check <a class="el" href="dev_guide_convolution.html#dg_conv_impl_limits">Implementation Limitations</a> section below.</dd></dl>
<h3>Data Representation</h3>
<p>Like other CNN primitives, the convolution primitive expects the following tensors:</p>
<table class="doxtable">
<tr>
<th align="left">Spatial </th><th align="left">Source / Destination </th><th align="left">Weights  </th></tr>
<tr>
<td align="left">1D </td><td align="left">\(N \times C \times W\) </td><td align="left">\([G \times ] OC \times IC \times KW\) </td></tr>
<tr>
<td align="left">2D </td><td align="left">\(N \times C \times H \times W\) </td><td align="left">\([G \times ] OC \times IC \times KH \times KW\) </td></tr>
<tr>
<td align="left">3D </td><td align="left">\(N \times C \times D \times H \times W\) </td><td align="left">\([G \times ] OC \times IC \times KD \times KH \times KW\) </td></tr>
</table>
<p>Physical format of data and weights memory objects is critical for convolution primitive performance. In the oneDNN programming model, convolution is one of the few primitives that support the placeholder memory format tag <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> (shortened to <code>any</code> from now on) and can define data and weight memory objects format based on the primitive parameters. When using <code>any</code> it is necessary to first create a convolution primitive descriptor and then query it for the actual data and weight memory objects formats.</p>
<p>While convolution primitives can be created with memory formats specified explicitly, the performance is likely to be suboptimal.</p>
<p>The table below shows the combinations for which <b>plain</b> memory formats the convolution primitive is optimized for.</p>
<table class="doxtable">
<tr>
<th align="left">Spatial </th><th align="left">Convolution Type </th><th align="left">Data / Weights logical tensor </th><th align="left">Implementation optimized for memory formats  </th></tr>
<tr>
<td align="left">1D, 2D, 3D </td><td align="left"></td><td align="left"><code>any</code> </td><td align="left"><em>optimized</em> </td></tr>
<tr>
<td align="left">1D </td><td align="left">f32, bf16 </td><td align="left">NCW / OIW, GOIW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dab55cb1d54480dd7f796bf66eea3ad32f" title="3D CNN activations tensor, an alias to dnnl_abc ">dnnl_ncw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dadff5ea69392d7e4da23179dc0ba7cbc2" title="plain 3D tensor ">dnnl_abc</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae6bd836b8515857585336a0921e35663" title="3D CNN weights tensor, an alias to dnnl_abc ">dnnl_oiw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dadff5ea69392d7e4da23179dc0ba7cbc2" title="plain 3D tensor ">dnnl_abc</a>), <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da7a95a9ab4d0be153fe304d94a4f96138" title="4D CNN weights tensor (incl. groups), an alias to dnnl_abcd ">dnnl_goiw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da6e669cc61278663a5ddbd3d0b25c6c5c" title="plain 4D tensor ">dnnl_abcd</a>) </td></tr>
<tr>
<td align="left">1D </td><td align="left">int8 </td><td align="left">NCW / OIW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da9f756dbdc1e949646c95f83e0f51bc43" title="3D CNN activations tensor, an alias to dnnl_acb ">dnnl_nwc</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daf8537ed269eb5d0586456db114039c00" title="permuted 3D tensor ">dnnl_acb</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da93eecc25f8ab1b07604b632401aa28e5" title="3D CNN weights tensor, an alias to dnnl_cba ">dnnl_wio</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da5a8de15eee2e5bcc2515eb7b01965789" title="permuted 3D tensor ">dnnl_cba</a>) </td></tr>
<tr>
<td align="left">2D </td><td align="left">f32, bf16 </td><td align="left">NCHW / OIHW, GOIHW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da83a751aedeb59613312339d0f8b90f54" title="4D CNN activations tensor, an alias to dnnl_abcd ">dnnl_nchw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da6e669cc61278663a5ddbd3d0b25c6c5c" title="plain 4D tensor ">dnnl_abcd</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da11176ff202375dcd0d06e2fba5f8a8e0" title="4D CNN weights tensor, an alias to dnnl_abcd ">dnnl_oihw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da6e669cc61278663a5ddbd3d0b25c6c5c" title="plain 4D tensor ">dnnl_abcd</a>), <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daee332d306e012c0614dc32e0ed66072f" title="5D CNN weights tensor (incl. groups), an alias to dnnl_abcde ">dnnl_goihw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da30d5d3c9de2931f06d265af81787ada3" title="plain 5D tensor ">dnnl_abcde</a>) </td></tr>
<tr>
<td align="left">2D </td><td align="left">int8 </td><td align="left">NCHW / OIHW, GOIHW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae50c534446b3c18cc018b3946b3cebd7" title="4D CNN activations tensor, an alias to dnnl_acdb ">dnnl_nhwc</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da8fcce5dd7260b5b0740e3b37b1e9ad41" title="permuted 4D tensor ">dnnl_acdb</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da4f4c7bd98c6d53fb3b69e1c8df0a80f6" title="4D CNN weights tensor, an alias to dnnl_cdba ">dnnl_hwio</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da2368e1a4ce9d9954fa10c242569eacb4" title="permuted 4D tensor ">dnnl_cdba</a>), <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da059c27962618c1f7670f5389bb7fb7ed" title="5D CNN weights tensor (incl. groups), an alias to dnnl_decab ">dnnl_hwigo</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da31fa5f2eb4a236664583afc291310ec6" title="permuted 5D tensor ">dnnl_decab</a>) </td></tr>
<tr>
<td align="left">3D </td><td align="left">f32, bf16 </td><td align="left">NCDHW / OIDHW, GOIDHW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae33b8c6790e5d37324f18a019658d464" title="5D CNN activations tensor, an alias to dnnl_abcde ">dnnl_ncdhw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da30d5d3c9de2931f06d265af81787ada3" title="plain 5D tensor ">dnnl_abcde</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da18e605a5f6afe9995961fc21fddf314e" title="5D CNN weights tensor, an alias to dnnl_abcde ">dnnl_oidhw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da30d5d3c9de2931f06d265af81787ada3" title="plain 5D tensor ">dnnl_abcde</a>), <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da621b8c724d93d2a5444feab224b2ce3e" title="6D CNN weights tensor (incl. groups), an alias to dnnl_abcdef ">dnnl_goidhw</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da74b2db34e6253e56f441764d16e6ec42" title="plain 6D tensor ">dnnl_abcdef</a>) </td></tr>
<tr>
<td align="left">3D </td><td align="left">int8 </td><td align="left">NCDHW / OIDHW </td><td align="left"><a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daa0d8b24eefd029e214080d3787114fc2" title="5D CNN activations tensor, an alias to dnnl_acdeb ">dnnl_ndhwc</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da0cfe86402763786b9b4d73062cfd2f05" title="permuted 5D tensor ">dnnl_acdeb</a>) / <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae4885779f955beeddc25443a3f8c2a63" title="5D CNN weights tensor, an alias to dnnl_cdeba ">dnnl_dhwio</a> (<a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dae7dd2b81eb2b502efbf65c888665b358" title="permuted 5D tensor ">dnnl_cdeba</a>) </td></tr>
</table>
<h3>Post-ops and Attributes</h3>
<p>Post-ops and attributes enable you to modify the behavior of the convolution primitive by applying the output scale to the result of the primitive and by chaining certain operations after the primitive. The following attributes and post-ops are supported:</p>
<table class="doxtable">
<tr>
<th align="left">Propagation </th><th align="left">Type </th><th align="left">Operation </th><th align="left">Description </th><th align="left">Restrictions  </th></tr>
<tr>
<td align="left">forward </td><td align="left">attribute </td><td align="left"><a class="el" href="structdnnl_1_1primitive__attr.html#a4b81acc8e48886313154f75c1708ae02">Output scale</a> </td><td align="left">Scales the result of convolution by given scale factor(s) </td><td align="left">int8 convolutions only </td></tr>
<tr>
<td align="left">forward </td><td align="left">post-op </td><td align="left"><a class="el" href="structdnnl_1_1post__ops.html#a66606f08467b19091e696b52a2f789e6">eltwise</a> </td><td align="left">Applies an <a class="el" href="group__dnnl__api__eltwise.html">Eltwise</a> operation to the result </td><td align="left"></td></tr>
<tr>
<td align="left">forward </td><td align="left">post-op </td><td align="left"><a class="el" href="structdnnl_1_1post__ops.html#a078ab8ec15423d2b3d26f3619a78ca38">sum</a> </td><td align="left">Adds the operation result to the destination tensor instead of overwriting it </td><td align="left"></td></tr>
</table>
<p>To facilitate dynamic quantization, the primitive supports run-time output scales. That means a user could configure attributes with output scales set to the <a class="el" href="group__dnnl__api__memory.html#gab16365c11b4dc88fbb453edb51f1979f" title="A wildcard value for floating point values that are unknown at a primitive creation time...">DNNL_RUNTIME_F32_VAL</a> wildcard value instead of the actual scales, if the scales are not known at the primitive descriptor creation stage. In this case, the user must provide the scales as an additional input memory object with argument <code>DNNL_ARG_ATTR_OUTPUT_SCALES</code> during the execution stage.</p>
<dl class="section note"><dt>Note</dt><dd>The library doesn't prevent using post-ops in training, but note that not all post-ops are feasible for training usage. For instance, using ReLU with non-zero negative slope parameter as a post-op would not produce an additional output <code>workspace</code> that is required to compute backward propagation correctly. Hence, in this particular case one should use separate convolution and eltwise primitives for training.</dd></dl>
<p>The following post-ops chaining is supported by the library:</p>
<table class="doxtable">
<tr>
<th align="left">Type of convolutions </th><th align="left">Post-ops sequence supported  </th></tr>
<tr>
<td align="left">f32 and bf16 convolution </td><td align="left">eltwise, sum, sum -&gt; eltwise </td></tr>
<tr>
<td align="left">int8 convolution </td><td align="left">eltwise, sum, sum -&gt; eltwise, eltwise -&gt; sum </td></tr>
</table>
<p>The attributes and post-ops take effect in the following sequence:</p>
<ul>
<li>Output scale attribute,</li>
<li>Post-ops, in order they were attached.</li>
</ul>
<p>The operations during attributes and post-ops applying are done in single precision floating point data type. The conversion to the actual destination data type happens just before the actual storing.</p>
<h4>Example 1</h4>
<p>Consider the following pseudo code:</p>
<div class="fragment"><div class="line">attribute attr;</div>
<div class="line">attr.set_output_scale(alpha);</div>
<div class="line">attr.set_post_ops({</div>
<div class="line">        { sum={scale=beta} },</div>
<div class="line">        { eltwise={scale=gamma, type=tanh, alpha=ignore, beta=ignored }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">convolution_forward(src, weights, dst, attr)</div>
</div><!-- fragment --><p>The would lead to the following:</p>
<p class="formulaDsp">
\[ \dst(\overline{x}) = \gamma \cdot \tanh \left( \alpha \cdot conv(\src, \weights) + \beta \cdot \dst(\overline{x}) \right) \]
</p>
<h4>Example 2</h4>
<p>The following pseudo code:</p>
<div class="fragment"><div class="line">attribute attr;</div>
<div class="line">attr.set_output_scale(alpha);</div>
<div class="line">attr.set_post_ops({</div>
<div class="line">        { eltwise={scale=gamma, type=relu, alpha=eta, beta=ignored }</div>
<div class="line">        { sum={scale=beta} },</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">convolution_forward(src, weights, dst, attr)</div>
</div><!-- fragment --><p>That would lead to the following:</p>
<p class="formulaDsp">
\[ \dst(\overline{x}) = \beta \cdot \dst(\overline{x}) + \gamma \cdot ReLU \left( \alpha \cdot conv(\src, \weights), \eta \right) \]
</p>
<h2>Algorithms</h2>
<p>oneDNN implements convolution primitives using several different algorithms:</p>
<ul>
<li><em>Direct</em>. The convolution operation is computed directly using SIMD instructions. This is the algorithm used for the most shapes and supports int8, f32 and bf16 data types.</li>
<li><em>Winograd</em>. This algorithm reduces computational complexity of convolution at the expense of accuracy loss and additional memory operations. The implementation is based on the <a href="https://arxiv.org/abs/1509.09308">Fast Algorithms for Convolutional Neural Networks by A. Lavin and S. Gray</a>. The Winograd algorithm often results in the best performance, but it is applicable only to particular shapes. Moreover, Winograd only supports int8 and f32 data types.</li>
<li><em>Implicit GEMM</em>. The convolution operation is reinterpreted in terms of matrix-matrix multiplication by rearranging the source data into a <a class="el" href="dev_guide_attributes_scratchpad.html">scratchpad memory</a>. This is a fallback algorithm that is dispatched automatically when other implementations are not available. GEMM convolution supports the int8, f32, and bf16 data types.</li>
</ul>
<h4>Direct Algorithm</h4>
<p>oneDNN supports the direct convolution algorithm on all supported platforms for the following conditions:</p>
<ul>
<li>Data and weights memory formats are defined by the convolution primitive (user passes <code>any</code>).</li>
<li>The number of channels per group is a multiple of SIMD width for grouped convolutions.</li>
<li>For each spatial direction padding does not exceed one half of the corresponding dimension of the weights tensor.</li>
<li>Weights tensor width does not exceed 14.</li>
</ul>
<p>In case any of these constraints are not met, the implementation will silently fall back to an explicit GEMM algorithm.</p>
<h4>Winograd Convolution</h4>
<p>oneDNN supports the Winograd convolution algorithm on systems with Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) support and Intel Deep Learning Boost (Intel DL Boost) under the following conditions:</p>
<ul>
<li>Data and weights memory formats are defined by the convolution primitive (user passes <code>any</code> as the data format).</li>
<li>The spatial domain is two-dimensional.</li>
<li>The weights shape is 3x3, there are no groups, dilation or strides ( \(KH = KW = 3\), \(SH = SW = 1\), and \(DH = DW = 0\)).</li>
<li>The data type is either int8 or f32.</li>
</ul>
<p>In case any of these constraints is not met, the implementation will silently fall back to the direct algorithm.</p>
<p>The Winograd convolution algorithm implementation additionally chooses tile size based on the problem shape and <a class="el" href="group__dnnl__api__primitives__common.html#gae3c1f22ae55645782923fbfd8b07d0c4">propagation kind</a>:</p>
<ul>
<li>For <code>forward_inference</code> oneDNN supports \(F(2 \times 2, 3 \times 3)\) or \(F(4 \times 4, 3 \times 3)\)</li>
<li>oneDNN supports only \(F(4 \times 4, 3 \times 3)\) Winograd for all the training propagation kinds.</li>
</ul>
<p>The following side effects should be weighed against the (potential) performance boost achieved from using the Winograd algorithm:</p>
<ul>
<li><em>Memory consumption</em>. Winograd implementation in oneDNN requires additional scratchpad memory to store intermediate results. As more convolutions using Winograd are added to the topology, the amount of memory required can grow significantly. This growth can be controlled if the scratchpad memory can be reused across multiple primitives. See <a class="el" href="dev_guide_attributes_scratchpad.html">Primitive Attributes: Scratchpad</a> for more details.</li>
<li><em>Accuracy</em>. In some cases Winograd convolution produce results that are significantly less accurate than results from the direct convolution.</li>
</ul>
<p>Create a Winograd convolution by simply creating a convolution descriptor (step 6 in <a class="el" href="cnn_inference_f32_cpp.html">simple network example</a> specifying the Winograd algorithm. The rest of the steps are exactly the same.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> conv1_desc = convolution_forward::desc(</div>
<div class="line">    prop_kind::forward_inference, algorithm::convolution_winograd,</div>
<div class="line">    conv1_src_md, conv1_weights_md, conv1_bias_md, conv1_dst_md,</div>
<div class="line">    conv1_strides, conv1_padding_l, conv1_padding_r);</div>
</div><!-- fragment --><h4>Automatic Algorithm Selection</h4>
<p>oneDNN supports <code><a class="el" href="group__dnnl__api__attributes.html#gga00377dd4982333e42e8ae1d09a309640acfdececd63a8bc0cfe1021ad614e2ded" title="Convolution algorithm that is chosen to be either direct or Winograd automatically. ">dnnl::algorithm::convolution_auto</a></code> algorithm that instructs the library to automatically select the <em>best</em> algorithm based on the heuristics that take into account tensor shapes and the number of logical processors available. (For automatic selection to work as intended, use the same thread affinity settings when creating the convolution as when executing the convolution.)</p>
<p><a class="anchor" id="dg_conv_impl_limits"></a></p>
<h2>Implementation Limitations</h2>
<ol type="1">
<li>Refer to <a class="el" href="dev_guide_data_types.html">Data Types</a> for limitations related to data types support.</li>
<li><b>CPU</b><ul>
<li>Winograd are implemented only for processors with Intel AVX-512 and Intel DL Boost instruction sets</li>
<li>Run-time output scales are not supported</li>
</ul>
</li>
<li><b>GPU</b><ul>
<li>No support for Winograd algorithm</li>
</ul>
</li>
</ol>
<h2>Performance Tips</h2>
<ul>
<li>Use <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> for source, weights, and destinations memory format tags when create a convolution primitive to allow the library to choose the most appropriate memory format.</li>
</ul>
<h2>Examples</h2>
<table class="doxtable">
<tr>
<th align="left">Engine </th><th align="left">Name </th><th align="left">Comments  </th></tr>
<tr>
<td align="left">CPU/GPU </td><td align="left"><a class="el" href="convolution_example_cpp.html">Convolution Primitive Example</a> </td><td align="left"><p class="starttd">This C++ API example demonstrates how to create and execute a <a class="el" href="dev_guide_convolution.html">Convolution</a> primitive in forward propagation mode.</p>
<p class="endtd">Key optimizations included in this example:</p>
<ul>
<li>Creation of optimized memory format from the primitive descriptor;</li>
<li>Primitive attributes with fused post-ops. </li>
</ul>
</td></tr>
</table>
</div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>