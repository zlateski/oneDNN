<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>oneDNN: RNN</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">oneAPI Deep Neural Network Library (oneDNN)
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RNN </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p></p>
<p><a class="el" href="group__dnnl__api__rnn.html">API Reference</a></p>
<p></p>
</blockquote>
<p>The RNN primitive computes a stack of unrolled recurrent cells, as depicted in Figure 1. \(\bias\), \(\srciter\) and \(\dstiter\) are optional parameters (the variable names follow the standard <a class="el" href="dev_guide_conventions.html">Naming Conventions</a>). If not provided, \(\bias\) and \(\srciter\) will default to 0.</p>
 <style>div.image img[src="unrolled_stack_rnn.jpg"]{width:80%;}</style> <div class="image">
<img src="unrolled_stack_rnn.jpg" alt="unrolled_stack_rnn.jpg"/>
<div class="caption">
Figure 1: Example of stacked recurrent cells unrolled over the time dimension and executed with the `left2right` direction. Dashed lines represent optional parameters.</div></div>
<p> The RNN primitive supports four modes for evaluation direction:</p>
<ul>
<li><code>left2right</code> will process the input data timestamps by increasing order</li>
<li><code>right2left</code> will process the input data timestamps by decreasing order</li>
<li><code>bidirectional_concat</code> will process all the stacked layers from <code>left2right</code> and from <code>right2left</code> independently, and will concatenate the output in \(\dstlayer\) over the channel dimension.</li>
<li><code>bidirectional_sum</code> will process all the stacked layers from <code>left2right</code> and from <code>right2left</code> independently, and will sum the two outputs to \(\dstlayer\).</li>
</ul>
<p>Even though the RNN primitive supports passing a different number of channels for \(\srclayer\), \(\srciter\), \(\dstlayer\), and \(\dstiter\), we always require the following conditions in order for the dimension to be consistent:</p>
<ul>
<li>\(channels(\dstlayer) = channels(\dstiter)\),</li>
<li>when \(T &gt; 1\), \(channels(\srciter) = channels(\dstiter)\),</li>
<li>when \(L &gt; 1\), \(channels(\srclayer) = channels(\dstlayer)\),</li>
<li>when using the <code>bidirectional_concat</code> direction, \(channels(\dstlayer) = 2 * channels(\dstiter)\).</li>
</ul>
<p>The general formula for the execution of a stack of unrolled recurrent cells depends on the current iteration of the previous layer ( \(h_{t,l-1}\) and \(c_{t,l-1}\)) and the previous iteration of the current layer ( \(h_{t-1, l}\)). Here is the exact equation for non-LSTM cells:</p>
<p class="formulaDsp">
\[ \begin{align} h_{t, l} = Cell(h_{t, l-1}, h_{t-1, l}) \end{align} \]
</p>
<p> where \(t,l\) are the indices of the timestamp and the layer of the cell being executed.</p>
<p>And here is the equation for LSTM cells:</p>
<p class="formulaDsp">
\[ \begin{equation*} (h_{t, l},c_{t,l}) = Cell(h_{t, l-1}, h_{t-1, l}, c_{t-1,l}) \end{equation*} \]
</p>
<p> where \(t,l\) are the indices of the timestamp and the layer of the cell being executed.</p>
<h1>Cell Functions</h1>
<p>The RNN API provides four cell functions:</p>
<ul>
<li><a href="#Vanilla-RNN">Vanilla RNN</a>, a single-gate recurrent cell,</li>
<li><a href="#LSTM">LSTM</a>, a four-gate long short-term memory cell,</li>
<li><a href="#GRU">GRU</a>, a three-gate gated recurrent unit cell,</li>
<li><a href="#Linear-before-reset-GRU">Linear-before-reset GRU</a>, a three-gate recurrent unit cell with the linear layer before the reset gate.</li>
</ul>
<h2>Vanilla RNN</h2>
<p>A single-gate recurrent cell initialized with <code>vanilla_rnn_forward::desc</code> or <code>vanilla_rnn_forward::desc</code> as in the following example. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vanilla_rnn_desc = vanilla_rnn_forward::desc(</div>
<div class="line">    aprop, activation, direction, src_layer_desc, src_iter_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, bias_desc,</div>
<div class="line">    dst_layer_desc, dst_iter_desc);</div>
</div><!-- fragment --><p>The Vanilla RNN cell supports the ReLU, Tanh and Sigmoid activation functions. The following equations defines the mathematical operation performed by the Vanilla RNN cell for the forward pass:</p>
<p class="formulaDsp">
\[ \begin{align} a_t &amp;= W \cdot h_{t,l-1} + U \cdot h_{t-1, l} + B \\ h_t &amp;= activation(a_t) \end{align} \]
</p>
<h2>LSTM</h2>
<h3>LSTM (or Vanilla LSTM)</h3>
<p>A four-gate long short-term memory recurrent cell initialized with <code>lstm_forward::desc</code> or <code>lstm_backward::desc</code> as in the following example.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lstm_desc = lstm_forward::desc(</div>
<div class="line">    aprop, direction, src_layer_desc, src_iter_h_desc, src_iter_c_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, bias_desc, dst_layer_desc,</div>
<div class="line">    dst_iter_h_desc, dst_iter_c_desc);</div>
</div><!-- fragment --><p>Note that for all tensors with a dimension depending on the gates number, we implicitly require the order of these gates to be <code>i</code>, <code>f</code>, \(\tilde c\), and <code>o</code>. The following equation gives the mathematical description of these gates and output for the forward pass:</p>
<p class="formulaDsp">
\[ \begin{align} i_t &amp;= \sigma(W_i \cdot h_{t,l-1} + U_i \cdot h_{t-1, l} + B_i) \\ f_t &amp;= \sigma(W_f \cdot h_{t,l-1} + U_f \cdot h_{t-1, l} + B_f) \\ \\ \tilde c_t &amp;= tanh(W_{\tilde c} \cdot h_{t,l-1} + U_{\tilde c} \cdot h_{t-1, l} + B_{\tilde c}) \\ c_t &amp;= f_t * c_{t-1} + i_t * \tilde c_t \\ \\ o_t &amp;= \sigma(W_o \cdot h_{t,l-1} + U_o \cdot h_{t-1, l} + B_o) \\ h_t &amp;= tanh(c_t) * o_t \end{align} \]
</p>
<p>where \(W_*\) are stored in \(\weightslayer\), \(U_*\) are stored in \(\weightsiter\) and \(B_*\) are stored in \(\bias\).</p>
<dl class="section note"><dt>Note</dt><dd>In order for the dimensions to be consistent, we require \(channels(\srciterc) = channels(\dstiterc) = channels(\dstiter)\).</dd></dl>
<h3>LSTM with Peephole</h3>
<p>A four-gate long short-term memory recurrent cell with peephole initialized with <code>lstm_forward::desc</code> or <code>lstm_backward::desc</code> as in the following example.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lstm_desc = lstm_forward::desc(</div>
<div class="line">    aprop, direction, src_layer_desc, src_iter_h_desc, src_iter_c_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, weights_peephole_desc,</div>
<div class="line">    bias_desc, dst_layer_desc, dst_iter_h_desc, dst_iter_c_desc);</div>
</div><!-- fragment --><p>Similarly to vanilla LSTM, we implicitly require the order of the gates to be <code>i</code>, <code>f</code>, \(\tilde c\), and <code>o</code> for all tensors with a dimension depending on the gates. For peephole weights, the gates order is <code>i</code>, <code>f</code>, <code>o</code>. The following equation gives the mathematical description of these gates and output for the forward pass:</p>
<p class="formulaDsp">
\[ \begin{align} i_t &amp;= \sigma(W_i \cdot h_{t,l-1} + U_i \cdot h_{t-1, l} + P_i \cdot c_{t-1} + B_i) \\ f_t &amp;= \sigma(W_f \cdot h_{t,l-1} + U_f \cdot h_{t-1, l} + P_f \cdot c_{t-1} + B_f) \\ \\ \tilde c_t &amp;= tanh(W_{\tilde c} \cdot h_{t,l-1} + U_{\tilde c} \cdot h_{t-1, l} + B_{\tilde c}) \\ c_t &amp;= f_t * c_{t-1} + i_t * \tilde c_t \\ \\ o_t &amp;= \sigma(W_o \cdot h_{t,l-1} + U_o \cdot h_{t-1, l} + P_o \cdot c_t + B_o) \\ h_t &amp;= tanh(c_t) * o_t \end{align} \]
</p>
<p>where \(P_*\) are stored in <code>weights_peephole</code>, and the other parameters are the same as in vanilla LSTM.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>weights_peephole_desc</code> passed to the operation descriptor constructor is a zero memory desciptor, the primitive will behave the same as in LSTM primitive without peephole.</dd></dl>
<h3>LSTM with Projection</h3>
<p>A four-gate long short-term memory recurrent cell with projection initialized with <code>lstm_forward::desc</code> or <code>lstm_backward::desc</code> as in the following example.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lstm_desc = lstm_forward::desc(</div>
<div class="line">    aprop, direction, src_layer_desc, src_iter_h_desc, src_iter_c_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, weights_peephole_desc,</div>
<div class="line">    weights_projection_desc, bias_desc, dst_layer_desc, dst_iter_h_desc,</div>
<div class="line">    dst_iter_c_desc);</div>
</div><!-- fragment --><p>Similarly to vanilla LSTM, we implicitly require the order of the gates to be <code>i</code>, <code>f</code>, \(\tilde c\), and <code>o</code> for all tensors with a dimension depending on the gates. The following equation gives the mathematical description of these gates and output for the forward pass (for simplicity, LSTM without peephole is shown):</p>
<p class="formulaDsp">
\[ \begin{align} i_t &amp;= \sigma(W_i \cdot h_{t,l-1} + U_i \cdot h_{t-1,l} + B_i) \\ f_t &amp;= \sigma(W_f \cdot h_{t,l-1} + U_f \cdot h_{t-1,l} + B_f) \\ &amp; \\ \tilde{c}_t &amp;= \tanh(W_{\tilde{c}} \cdot h_{t,l-1} + U_{\tilde{c}} \cdot h_{t-1,l} + B_{\tilde{c}}) \\ c_t &amp;= f_t * c_{t-1} + i_t * \tilde{c}_t \\ &amp; \\ o_t &amp;= \sigma(W_o \cdot h_{t,l-1} + U_o \cdot h_{t-1,l} + B_o) \\ h_t &amp;= R \cdot (\tanh(c_t) * o_t) \end{align} \]
</p>
<p>where \(R\) is stored in <code>weights_projection</code>, and the other parameters are the same as in vanilla LSTM.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>weights_projection_desc</code> passed to the operation descriptor constructor is a zero memory desciptor, the primitive will behave the same as in LSTM primitive without projection.</dd></dl>
<h2>GRU</h2>
<p>A three-gate gated recurrent unit cell, initialized with <code>gru_forward::desc</code> or <code>gru_backward::desc</code> as in the following example. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> gru_desc = gru_forward::desc(</div>
<div class="line">    aprop, direction, src_layer_desc, src_iter_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, bias_desc,</div>
<div class="line">    dst_layer_desc, dst_iter_desc);</div>
</div><!-- fragment --><p>Note that for all tensors with a dimension depending on the gates number, we implicitly require the order of these gates to be <code>u</code>, <code>r</code>, and <code>o</code>. The following equation gives the mathematical definition of these gates.</p>
<p class="formulaDsp">
\[ \begin{align} u_t &amp;= \sigma(W_u \cdot h_{t,l-1} + U_u \cdot h_{t-1, l} + B_u) \\ r_t &amp;= \sigma(W_r \cdot h_{t,l-1} + U_r \cdot h_{t-1, l} + B_r) \\ o_t &amp;= tanh(W_o \cdot h_{t,l-1} + U_o \cdot (r_t * h_{t-1, l}) + B_o) \\ h_t &amp;= u_t * h_{t-1, l} + (1 - u_t) * o_t \end{align} \]
</p>
<p>where \(W_*\) are in \(\weightslayer\), \(U_*\) are in \(\weightsiter\), and \(B_*\) are stored in \(\bias\).</p>
<dl class="section note"><dt>Note</dt><dd>If you need to replace u_t by (1-u_t) when computing h_t, you can achieve this by multiplying \(W_u\), \(U_u\) and \(B_u\) by \(-1\). This is possible as \(u_t = \sigma(W_u \cdot h_{t,l-1} + U_u \cdot h_{t-1, l} + B_u)\), and \(1 – \sigma(a) = \sigma(-a)\).</dd></dl>
<h2>Linear-Before-Reset GRU</h2>
<p>A three-gate gated recurrent unit cell with linear layer applied before the reset gate, initialized with or as in the following example. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lbr_gru_desc = lbr_gru_forward::desc(</div>
<div class="line">    aprop, direction, src_layer_desc, src_iter_desc,</div>
<div class="line">    weights_layer_desc, weights_iter_desc, bias_desc,</div>
<div class="line">    dst_layer_desc, dst_iter_desc);</div>
</div><!-- fragment --><p>The following equation describes the mathematical behavior of the Linear-Before-Reset GRU cell.</p>
<p class="formulaDsp">
\[ \begin{align} u_t &amp;= \sigma(W_u \cdot h_{t,l-1} + U_u \cdot h_{t-1, l} + B_u) \\ r_t &amp;= \sigma(W_r \cdot h_{t,l-1} + U_r \cdot h_{t-1, l} + B_r) \\ o_t &amp;= tanh(W_o \cdot h_{t,l-1} + r_t *(U_o \cdot h_{t-1, l} + B_{u&#39;}) + B_o) \\ h_t &amp;= u_t * h_{t-1, l} + (1 - u_t) * o_t \end{align} \]
</p>
<p>Note that for all tensors with a dimension depending on the gates number, except the bias, we implicitly require the order of these gates to be <code>u</code>, <code>r</code>, and <code>o</code>. For the \(\bias\) tensor, we implicitly require the order of the gates to be <code>u</code>, <code>r</code>, <code>o</code>, and <code>u'</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If you need to replace u_t by (1-u_t) when computing h_t, you can achieve this by multiplying \(W_u\), \(U_u\) and \(B_u\) by \(-1\). This is possible as \(u_t = \sigma(W_u \cdot h_{t,l-1} + U_u \cdot h_{t-1, l} + B_u)\), and \(1 – \sigma(a) = \sigma(-a)\).</dd></dl>
<h1>Considerations for Training</h1>
<p>When using the RNN API for training, the forward pass should use the <code>forward_training</code> propagation kind, and a workspace should be passed to both the forward pass and the backward pass. Note that after executing the backward pass, the workspace is no more valid and should be populated once again by another forward pass.</p>
<p><a class="anchor" id="dg_rnn_impl_limits"></a> </p>
<h1>Execution Arguments</h1>
<p>When executed, the inputs and outputs should be mapped to an execution argument index as specified by the following table. </p>
<table class="doxtable">
<tr>
<th>Primitive input/output </th><th>Execution argument index  </th></tr>
<tr>
<td>\(\srclayer\) </td><td>DNNL_ARG_SRC_LAYER </td></tr>
<tr>
<td>\(\srciter\) </td><td>DNNL_ARG_SRC_ITER </td></tr>
<tr>
<td>\(\srciterc\) </td><td>DNNL_ARG_SRC_ITER_C </td></tr>
<tr>
<td>\(\weightslayer\) </td><td>DNNL_ARG_WEIGHTS_LAYER </td></tr>
<tr>
<td>\(\weightsiter\) </td><td>DNNL_ARG_WEIGHTS_ITER </td></tr>
<tr>
<td>\(\weightspeephole\) </td><td>DNNL_ARG_WEIGHTS_PEEPHOLE </td></tr>
<tr>
<td>\(\weightsprojection\) </td><td>DNNL_ARG_WEIGHTS_PROJECTION </td></tr>
<tr>
<td>\(\bias\) </td><td>DNNL_ARG_BIAS </td></tr>
<tr>
<td>\(\dstlayer\) </td><td>DNNL_ARG_DST_LAYER </td></tr>
<tr>
<td>\(\dstiter\) </td><td>DNNL_ARG_DST_ITER </td></tr>
<tr>
<td>\(\dstiterc\) </td><td>DNNL_ARG_DST_ITER_C </td></tr>
<tr>
<td>\(\workspace\) </td><td>DNNL_WORKSPACE </td></tr>
<tr>
<td>\(\diffsrclayer\) </td><td>DNNL_ARG_DIFF_SRC_LAYER </td></tr>
<tr>
<td>\(\diffsrciter\) </td><td>DNNL_ARG_DIFF_SRC_ITER </td></tr>
<tr>
<td>\(\diffsrciterc\) </td><td>DNNL_ARG_DIFF_SRC_ITER_C </td></tr>
<tr>
<td>\(\diffweightslayer\) </td><td>DNNL_ARG_DIFF_WEIGHTS_LAYER </td></tr>
<tr>
<td>\(\diffweightsiter\) </td><td>DNNL_ARG_DIFF_WEIGHTS_ITER </td></tr>
<tr>
<td>\(\diffweightspeephole\) </td><td>DNNL_ARG_DIFF_WEIGHTS_PEEPHOLE </td></tr>
<tr>
<td>\(\diffweightsprojection\) </td><td>DNNL_ARG_DIFF_WEIGHTS_PROJECTION </td></tr>
<tr>
<td>\(\diffbias\) </td><td>DNNL_ARG_DIFF_BIAS </td></tr>
<tr>
<td>\(\diffdstlayer\) </td><td>DNNL_ARG_DIFF_DST_LAYER </td></tr>
<tr>
<td>\(\diffdstiter\) </td><td>DNNL_ARG_DIFF_DST_ITER </td></tr>
<tr>
<td>\(\diffdstiterc\) </td><td>DNNL_ARG_DIFF_DST_ITER_C </td></tr>
</table>
<h1>Implementation details</h1>
<h2>Data Types</h2>
<p>The following table lists the combination of data types supported by the RNN primitive for each input and output memory object.</p>
<table class="doxtable">
<tr>
<th>Propagation </th><th>Cell Function </th><th>Input data </th><th>Recurrent data (1) </th><th>Weights </th><th>Bias </th><th>Output Data  </th></tr>
<tr>
<td>Forward / Backward </td><td>All </td><td>f32 </td><td>f32 </td><td>f32 </td><td>f32 </td><td>f32 </td></tr>
<tr>
<td>Forward / Backward (2) </td><td>All (3) </td><td>bf16 </td><td>bf16 </td><td>bf16 </td><td>f32 </td><td>bf16 </td></tr>
<tr>
<td>Forward </td><td>All (3) </td><td>f16 </td><td>f16 </td><td>f16 </td><td>f16 </td><td>f16 </td></tr>
<tr>
<td>Forward inference </td><td>Vanilla LSTM </td><td>u8 </td><td>u8 </td><td>s8 </td><td>f32 </td><td>u8, f32 </td></tr>
</table>
<p>(1) With LSTM and Peephole LSTM cells, the cell state datatype is always f32.</p>
<p>(2) In backward propagation, all <code>diff_*</code> tensors are in f32.</p>
<p>(3) Projection LSTM is not supported.</p>
<dl class="section warning"><dt>Warning</dt><dd>There might be hardware and/or implementation specific restrictions. Check <a class="el" href="dev_guide_rnn.html#dg_rnn_impl_limits">Implementation Limitations</a> section below.</dd></dl>
<h2>Data Representation</h2>
<p>In the oneDNN programming model, the RNN primitive is one of a few that support the placeholder memory format <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> (shortened to <code>any</code> from now on) and can define data and weight memory objects format based on the primitive parameters.</p>
<p>The following table summarizes the data layouts supported by the RNN primitive.</p>
<table class="doxtable">
<tr>
<th>Input/Output Data </th><th>Recurrent Data </th><th>Layer and Iteration Weights </th><th>Peephole Weights and Bias </th><th>Projection LSTM Weights  </th></tr>
<tr>
<td>any </td><td>any </td><td>any </td><td>ldgo </td><td>any, ldio (Forward propagation) </td></tr>
<tr>
<td>ntc, tnc </td><td>ldnc </td><td>ldigo, ldgoi </td><td>ldgo </td><td>any, ldio (Forward propagation) </td></tr>
</table>
<p>While an RNN primitive can be created with memory formats specified explicitly, the performance is likely to be sub-optimal. When using <code>any</code> it is necessary to first create an RNN primitive descriptor and then query it for the actual data and weight memory objects formats.</p>
<dl class="section note"><dt>Note</dt><dd>The RNN primitive supports padded tensors and views. So even if two memory descriptors share the same data layout, they might still be different.</dd></dl>
<h2>Post-ops and Attributes</h2>
<p>Currently post-ops and attributes are only used by the int8 variant of LSTM. See the markdown <a class="el" href="cpu_rnn_inference_int8_cpp.html">RNN int8 inference example</a> for more details on how to use and set these quantization parameters.</p>
<h1>Implementation Limitations</h1>
<ol type="1">
<li>Refer to <a class="el" href="dev_guide_data_types.html">Data Types</a> for limitations related to data types support.</li>
<li><b>CPU</b><ul>
<li>Bias must always be present (that is, the corresponding memory descriptor argument cannot be zero memory descriptor when the RNN operation descriptor is initialized).</li>
</ul>
</li>
</ol>
<ol type="1">
<li><b>GPU</b><ul>
<li>No support for GRU</li>
<li>No support for Peephole LSTM and Projection LSTM</li>
<li>Bias must always be present (that is, the corresponding memory descriptor argument cannot be zero memory descriptor when the RNN operation descriptor is initialized).</li>
</ul>
</li>
</ol>
<h2>Examples</h2>
<table class="doxtable">
<tr>
<th align="left">Engine </th><th align="left">Name </th><th align="left">Comments  </th></tr>
<tr>
<td align="left">CPU/GPU </td><td align="left"><a class="el" href="lstm_example_cpp.html">LSTM RNN Primitive Example</a> </td><td align="left"><p class="starttd">This C++ API example demonstrates how to create and execute an <a class="el" href="dev_guide_rnn.html">LSTM RNN</a> primitive in forward training propagation mode.</p>
<p class="endtd">Key optimizations included in this example:</p>
<ul>
<li>Creation of optimized memory format from the primitive descriptor. </li>
</ul>
</td></tr>
</table>
</div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>